{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introductiondocker笔记Introduction docker笔记 原视频地址: 基础版:【狂神说Java】Docker最新超详细版教程通俗易懂 进阶版:【狂神说Java】Docker进阶篇超详细版教程通俗易懂 后续还在更新,敬请期待 ^_^ 整理不易,请给小编一个star 更多文档链接:点我查看 友情链接 github:https://github.com/victorfengming 码云:https://gitee.com/victorfengming csdn:https://blog.csdn.net/qq_40223983 博客园:https://www.cnblogs.com/victorfengming/ 开源中国:https://my.oschina.net/victorfengming 其他相关推荐: Golang,Google开发的一种静态强类型、编译型语言 Python,解释型、面向对象、动态数据类型的高级程序设计语言 Java,应用最广泛的,面向对象的高级程序设计语言 前端,HTML+CSS+JS mybatis,支持定制化SQL,存储过程以及高级映射的优秀的持久层框架 django,Python驱动的一个开源模型-视图-控制器风格的Web框架 beego,Go应用的HTTP框架,用来快速开发API、Web及后端服务 flask,使用 Python 编写的轻量级 Web 应用框架 jenkins,Jenkins是一个开源的,基于Java开发的一种持续集成工具 mysql,最流行的关系型数据库管理系统 nosql,非关系型数据库是对关系型数据库的一种补充 redis,C开发的,高性能,内存,键值对儿nosql数据库 pyqt5, 用来创建Python GUI应用程序的工具包 springboot,简化新Spring应用的初始搭建以及开发过程的新框架 Docker,基于Go的开源的应用容器引擎 Data Science,Python大数据相关,人工智能数据分析基础 elasticsearch,RESTful 风格的分布式开源搜索和分析引擎 阿里巴巴,阿里巴巴中文站架构设计实践(何崚).pdf.pdf)new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-23 14:45:03 "},"base/2020-07-01-docker_学习大纲.html":{"url":"base/2020-07-01-docker_学习大纲.html","title":"学习大纲","keywords":"","body":"Docker 学习Docker 学习 docker 概述 docker 安装 docker 命令 镜像命令 容器命令 操作命令 ...命令 docker 镜像! 容器数据卷! DockerFile Docker网络原理 IDEA整合Docker Docker Compose Docker Swarm CI\\CD Jenkins 知道的越多,不知道的越多! 授人以鱼,学习思想! 即使再小的帆也能远航 只要学不死,就网死里学 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-12 19:53:49 "},"base/2020-07-02-docker_概述.html":{"url":"base/2020-07-02-docker_概述.html","title":"概述","keywords":"","body":"docker 概述docker为什么出现docker 概述 docker为什么出现 一款产品:开发-上线 两套环境! 应用环境,应用配置! 开发 --- 运维. 问题: 我在我的电脑上可以运行! 版本更新,导致服务不可用!对于运维来说,考研就十分大? 环境配置是十分的麻烦,每个机器都要部署环境(集群Redis,ES,Hadoop...)! 费时费力. 发布一个项目(Jar+(Redis MySQL jdk ES)),项目能不能都带上环境安装打包! 之前在配置服务器一个应用的环境Redis MySQL jdk ES Hadoop,配置超麻烦了,不能够跨平台. Window,最后发布到Linux! 传统:开发jar,运维来做! 现在:开发打包部署上线,一套流程做完! java -- apk -- 发布(应用商店)--- 张三使用apk --- 安装即可用! java -- jar(环境) --- 打包项目带上环境(镜像) -- (Docker仓库:商店) -- 下载我们发布的镜像 -- 直接运行即可! Docker给以上的问题,提出了解觉方案! Docker 的思想就来自于集装箱 JRE -- 多个应用(端口冲突) -- 原来都是交叉的 隔离:Docker核心思想!打包装箱!每个箱子是互相隔离的 水果 生化武器 Docker 通过隔离机制,可以将服务器利用到机制! 本质:所有的技术都是因为出现了一些问题,我们需要去解决,才去学习!new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-12 19:53:49 "},"base/2020-07-03-docker_历史.html":{"url":"base/2020-07-03-docker_历史.html","title":"历史","keywords":"","body":"docker 的历史Docker 能干嘛docker 的历史 2010年,几个搞IT的年轻人,在美国成立了一家公司dotcloud 做一些pass云服务! lxc有关的容器技术!(虚拟机) 他们将自己的技术 (容器化技术) 命名 就是 Docker! Docker刚刚诞生的时候,没有引起行业的注意!dotcloud ,就活不下去! 做开源开放源代码! 2013年,Docker开源! 很多人觉得这玩意好,越来越多的人觉得好啊 火了,Docker每个月都会更新一个版本! 2014年4月9日,Docker1.0发布! Docker为什么这么火?十分的轻巧! 在容器技术出来之前,我们都是使用虚拟机技术! 虚拟机: 在window中装一个Vm ware,通过这个软件我们可以虚拟出来一台或多台电脑!笨重! 虚拟机也是属于虚拟化技术,Docker容器技术,也是一种虚拟化技术! vm: linux centos 原生镜像(一个电脑!) 隔离,需要开启多个虚拟机! docker: 隔离 ,镜像 (最核心的环境 4M+ jdk + mysql )十分的小巧,运行镜像就可以了!小巧!几个M KB 秒级启动! 到现在,所有开发人员都必须会Docker Docker是基于GO语言开发的!开源项目! 官方文档 docker 的文档是超级详细的 dockerhub git push 可以发布的自己的镜像 Docker 能干嘛 之前的虚拟机技术 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-12 19:53:49 "},"base/2020-07-04-docker_能做设么么.html":{"url":"base/2020-07-04-docker_能做设么么.html","title":"能做设么么","keywords":"","body":"Docker 能干嘛DevOps(开发\\运维)Docker 能干嘛 之前的虚拟机技术 虚拟机技术缺点: 资源占用十分多 冗余步骤多 启动很慢! 容器化技术 容器化技术不是模拟的一个完整的操作系统 比较Docker和虚拟机技术的不同: 传统虚拟机,虚拟出一条硬件,运行一个完整的操作系统,然后再这个系统上安装和运行软件 容器内的应用直接运行在宿主机的内核,容器是没有自己的内核,也没有虚拟我们的硬件,所以就轻便了 每个容器间是互相隔离,每个容器内都有一个属于自己的文件系统,互补影响. DevOps(开发\\运维) 而更快速的交付和部署 传统: 一对帮助文档,安装程序 Docker: 一键运行打包镜像发布测试 更便捷的升级和扩缩容 使用了docker之后,我们部署应用就和搭积木一样! SpringBoot 1.5 Redis5 tomcat 8升级 升级后需要联调测试 项目打包为一个镜像,扩展服务器A! 服务器B 更简单的系统运维 在容器化之后,我们的开发,测试环境都是高度一致的 更高效的计算资源利用: 1核2G的服务器,能够运行几十个tomcat几十个redis Docker是内核级别的虚拟化,可以在一个物理机上可以运行很多的容器实例 服务器的性能被压缩到极致. 只要学不死就往思利血 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-12 19:53:49 "},"base/2020-07-05-docker_名词概念.html":{"url":"base/2020-07-05-docker_名词概念.html","title":"名词概念","keywords":"","body":"Docker 安装docker基本的组成镜像(image):容器(container)仓库(repository)Docker 安装 docker基本的组成 镜像(image): docker镜像就好比是一个模板,可以通过这个模板来创建容器服务,tomcat镜像===>run===> tomcat01容器(提供服务器),通过这个镜像可以创建多个容器(最终服务运行或者项目运行就是在容器中的) 容器(container) Docker利用容器技术,独立运行一个或者一个组应用,通过镜像来创建的 启动,停止,删除,基本命令! 目前就可以把这个容器理解为就是一个简单的linux系统 仓库(repository) 仓库就是存放镜像的地方,!我们这个 仓库分为公有仓库和私有仓库! Docker Hub 阿里云... 网易云 华为云 都有容器服务器(配置镜像加速...) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-12 19:53:49 "},"base/2020-07-06-docker_安装.html":{"url":"base/2020-07-06-docker_安装.html","title":"安装","keywords":"","body":"Docker 安装环境准备环境查看安装3.设置镜像的仓库4. 现在就可以安装最新的docker的引擎5. 如果想要安装不是最新版本的,也可以指定安装的版本Docker 安装 环境准备 需要会一点点儿的Linux基础 Centos7 我们使用Xshell连接远程服务器进行操作 环境查看 centos版本 3.10.0-514.26.2.el7.x86_64 ## 系统版本 NAME=\"CentOS Linux\" VERSION=\"7 (Core)\" ID=\"centos\" ID_LIKE=\"rhel fedora\" VERSION_ID=\"7\" PRETTY_NAME=\"CentOS Linux 7 (Core)\" ANSI_COLOR=\"0;31\" CPE_NAME=\"cpe:/o:centos:centos:7\" HOME_URL=\"https://www.centos.org/\" BUG_REPORT_URL=\"https://bugs.centos.org/\" CENTOS_MANTISBT_PROJECT=\"CentOS-7\" CENTOS_MANTISBT_PROJECT_VERSION=\"7\" REDHAT_SUPPORT_PRODUCT=\"centos\" REDHAT_SUPPORT_PRODUCT_VERSION=\"7\" 安装 帮助文档 # 1. 卸载旧的版本 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2.# 需要的安装包 sudo yum install -y yum-utils 3.设置镜像的仓库 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 默认是从国外下载的,我们是使用国内的 docker阿里云国内镜像地址 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 推荐使用阿里云的 在安装之前建议更新yum更新索引 sudo yum makecache fast 4. 现在就可以安装最新的docker的引擎 sudo yum install docker-ce docker-ce-cli containerd.io docker-ce 是社区版本的 docker-ee 是企业版本的 5. 如果想要安装不是最新版本的,也可以指定安装的版本 sudo yum install docker-ce- docker-ce-cli- containerd.io 安装完成之后就可以启动docker,最后helloworld sudo systemctl start docker 使用docker version 看看安装成功没 [root@iz8g9301trfnpxz /]# docker version Client: Docker Engine - Community Version: 19.03.12 API version: 1.40 Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:46:54 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.12 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:45:28 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.13 GitCommit: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc: Version: 1.0.0-rc10 GitCommit: dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init: Version: 0.18.0 GitCommit: fec3683 docker helloworld ```cmd [root@iz8g9301trfnpxz /]# docker run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: The Docker client contacted the Docker daemon. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ 8. 查看一下下载的helloworld的镜像 在不在 ```cmd [root@iz8g9301trfnpxz /]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 6 months ago 13.3kB [root@iz8g9301trfnpxz /]# 卸载dockerUninstall Docker Engine Uninstall the Docker Engine, CLI, and Containerd packages: # 卸载依赖 $ sudo yum remove docker-ce docker-ce-cli containerd.io Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes: # 删除资源(目录)(linux系统一切皆文件) $ sudo rm -rf /var/lib/docker You must delete any edited configuration files manually. # /var/lib/docker docker 的默认工作路径 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:46:35 "},"base/2020-07-07-docker_阿里云镜像加速.html":{"url":"base/2020-07-07-docker_阿里云镜像加速.html","title":"阿里云镜像加速","keywords":"","body":"阿里云镜像加速阿里云镜像加速 登录阿里云 找到镜像加速服务 操作文档 不同的系统,操作不同 加速器地址:https://hozxrmk0.mirror.aliyuncs.com 配置使用 ```xml 安装／升级Docker客户端 推荐安装1.10.0以上版本的Docker客户端，参考文档 docker-ce 配置镜像加速器 针对Docker客户端版本大于 1.10.0 的用户 您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器 ``` 执行以下4步骤命令 ```cmd sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json https://hozxrmk0.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:46:35 "},"base/2020-07-08-docker_Run的流程和Docker原理.html":{"url":"base/2020-07-08-docker_Run的流程和Docker原理.html","title":"Run的流程和Docker原理","keywords":"","body":"docker是怎么工作的Docker为什么比VM块docker是怎么工作的 Docker 是一个Client - Server 结构的系统,Docker的守护进行运行在主机上.通过Socket从客户端访问! DockerServer 接收到Docker-Client的指令,就会执行这个命令! Docker为什么比VM块 docker 有着比虚拟机更少的抽象层 docker 利用的是宿主机的内核vm需要时GuestOS. 所以说,新建一个容器的时候,docker不需要像虚拟机一样重新加载一个操作系统内核,避免引导. 虚拟机是加载GuestOS,分钟级别的,而docker是利用宿主机的操作系统吗,省略了这个复杂的过程,秒级别 之后学习完毕所有的命令,再回过头来看这段理论就会很清晰! 理论 实践 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-12 19:53:49 "},"base/2020-07-09-docker_常用命令.html":{"url":"base/2020-07-09-docker_常用命令.html","title":"常用命令","keywords":"","body":"docker的常用命令帮助命令帮助文档的地址镜像命令docker images 查看所有本地主机上的镜像docker search 搜素docker pull 下载镜像指定版本下载删除镜像容器命令docker的常用命令 大家现在是抹零两可的 帮助命令 docker version # 显示docker 版本信息 docker info # 显示docker的系统信息,包括机镜像和容器的数量 更加详细的信息 docker --help # 帮助命令 帮助文档的地址 ```https://docs.docker.com/reference/ 镜像命令和容器命令学会了连入门都不算 镜像命令 docker images 查看所有本地主机上的镜像 [root@iz8g9301trfnpxz /]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 6 months ago 13.3kB [root@iz8g9301trfnpxz /]# # # 解释 # REPOSITORY 镜像的仓库源 # TAG 镜像的标签 # IMAGE ID 镜像的ID # CREATED 镜像的创建时间 # SIZE 镜像的大小 # 可选项 -a , --all # 列出所有镜像 -q , --quiet # 只显示镜像的id [root@iz8g9301trfnpxz /]# docker images -a REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 6 months ago 13.3kB [root@iz8g9301trfnpxz /]# docker images -q bf756fb1ae65 [root@iz8g9301trfnpxz /]# docker search 搜素 [root@iz8g9301trfnpxz /]# docker search mysql NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 9780 [OK] mariadb MariaDB is a community-developed fork of MyS… 3569 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 717 [OK] centos/mysql-57-centos7 MySQL 5.7 SQL database server 78 [root@iz8g9301trfnpxz /]# docker search --help Usage: docker search [OPTIONS] TERM Search the Docker Hub for images # 可选项:通过收藏数量来过滤 Options: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output [root@iz8g9301trfnpxz /]# 比如这样 [root@iz8g9301trfnpxz /]# docker search mysql --filter=STARS=5000 NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 9780 [OK] docker pull 下载镜像 [root@iz8g9301trfnpxz /]# docker pull mysql Using default tag: latest latest: Pulling from library/mysql 6ec8c9369e08: Pull complete 177e5de89054: Pull complete ab6ccb86eb40: Pull complete e1ee78841235: Pull complete # 分层下载,docker image的核心 联合文件系统 09cd86ccee56: Pull complete 78bea0594a44: Pull complete caf5f529ae89: Pull complete cf0fc09f046d: Pull complete 4ccd5b05a8f6: Pull complete 76d29d8de5d4: Pull complete 8077a91f5d16: Pull complete 922753e827ec: Pull complete Digest: sha256:fb6a6a26111ba75f9e8487db639bc5721d4431beba4cd668a4e922b8f8b14acc # 签名 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest # 真实地址 如果不写版本 默认最新 docker pull mysql docker pull docker.io/library/mysql:latest 这两个命令是等价的 指定版本下载 [root@iz8g9301trfnpxz /]# docker pull mysql:5.7 5.7: Pulling from library/mysql 6ec8c9369e08: Already exists 177e5de89054: Already exists ab6ccb86eb40: Already exists e1ee78841235: Already exists 09cd86ccee56: Already exists 78bea0594a44: Already exists caf5f529ae89: Already exists 4e54a8bcf566: Pull complete 50c21ba6527b: Pull complete 68e74bb27b39: Pull complete 5f13eadfe747: Pull complete Digest: sha256:97869b42772dac5b767f4e4692434fbd5e6b86bcb8695d4feafb52b59fe9ae24 Status: Downloaded newer image for mysql:5.7 docker.io/library/mysql:5.7 分层下载的好处是前面的可以共用 linux的联合文件系统 现在再查看一下 [root@iz8g9301trfnpxz /]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql 5.7 8679ced16d20 7 days ago 448MB mysql latest e3fcc9e1cc04 7 days ago 544MB hello-world latest bf756fb1ae65 6 months ago 13.3kB [root@iz8g9301trfnpxz /]# 删除镜像 docker rmi -f imageid # 删除指定的image docker rmi -f imageid imageid # 删除指定的多个image docker rmi -f $(docker images -aq) # 删除全部容器 试一下 [root@iz8g9301trfnpxz /]# docker rmi -f 8679ced16d20 Untagged: mysql:5.7 Untagged: mysql@sha256:97869b42772dac5b767f4e4692434fbd5e6b86bcb8695d4feafb52b59fe9ae24 Deleted: sha256:8679ced16d206961b35686895b06cfafefde87ef02b518dfc2133081ebf47cda Deleted: sha256:355f87dc5125a32cc35898a4dde17fb067585bc0d86704b5a467c0ccc0eea484 Deleted: sha256:8299d5c38042216210125535adb2600e46268a0e2b9ec799d12ea5b770236e79 Deleted: sha256:07311a303b2c7cf2ac6992aaf68e12326fe7255985166939cbab7d18b10e0f47 Deleted: sha256:306c9bc1ce2997d000bb6f1ea4108420d9752df93ce39164b7a2f876b954afc4 删除多个 批量删除全部 [root@iz8g9301trfnpxz /]# docker rmi -f $(docker images -aq) Untagged: mysql:latest Untagged: mysql@sha256:fb6a6a26111ba75f9e8487db639bc5721d4431beba4cd668a4e922b8f8b14acc Deleted: sha256:e3fcc9e1cc046c92cfcea0d66cdb00fcb7747e87dde96dfc958bd80be37af117 Deleted: sha256:7a1c5c1a40dad78bacb211ec3d7918acdd78a76185fd33a167260c3e51e97fa4 Deleted: sha256:abb5f0f890ba2f327d30b5ca1bbc35584bc6357c8d6f4bdc2e4637cce2ea9a35 Deleted: sha256:919c56fc8230b0ddf8580e0a58d34ae1c5e48069d9b48cc41ae7a1cae82bb60e Deleted: sha256:962d6891622cf4a7e8932f6c76b2c2f3ab9cecb8aad71d55adacc2aece6b0181 Deleted: sha256:ab26019b1328bff5ea5132b5e3f52b9fd3808e734f1a39141fb9e5da561200e2 Deleted: sha256:06bd523b11319c8177ab2003cb31b296cea22b0201bf8ae987ac300118a0654f Deleted: sha256:a8681d5c66889e97303be147d30eb8ec4b0bd5bc0e2c774b4d94f52ec23c4649 Deleted: sha256:c28ab987d3964139dcd3852e1c10ef0a425d2705c71a3b68b411460279d8535d Deleted: sha256:c0fc32d1072662668dd59842d893e5ee125c1958931ae84630132b7bb6c09198 Deleted: sha256:da0ebf91b8bc2d545dbe73cbf9b7c7b25df71033f5057133a445e9c33a36ec7d Deleted: sha256:483d8f607b803b5e3d3f97adbad3b0e692670f223b2529ecae5d04888c29ad5d Deleted: sha256:95ef25a3204339de1edf47feaa00f60b5ac157a498964790c58c921494ce7ffd Untagged: hello-world:latest Untagged: hello-world@sha256:49a1c8800c94df04e9658809b006fd8a686cab8028d33cfba2cc049724254202 Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b [root@iz8g9301trfnpxz /]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE 容器命令 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:56:23 "},"base/2020-07-10-docker_容器命令.html":{"url":"base/2020-07-10-docker_容器命令.html","title":"容器命令","keywords":"","body":"容器命令从容器中退出主机列出所有的运行的容器退出容器删除容器启动和停止容器的操作容器命令 说明: 我们有了镜像才可以创建容器,linux,下载一个centos镜像来测试学习 docker pull centos 新建容器并启动 docker run [可选参数] image # 参数说明 --name=\"Name\" 容器名字 tomcat01 tomcat02 ,用来区分容器 -d 后台方式运行,ja nohup -i 使用交互方式运行,进入容器查看内容 -t 使用交互方式运行,进入容器查看内容 -p 指定容器的端口 -p 8080:8080 -p ip主机端口 : 容器端口 -p 主机端口 : 容器端口(这种方式常用) -p 容器端口 容器端口 -P 随机指定容器端口 测试一下 # 测试,启动并进入容器 [root@iz8g9301trfnpxz /]# docker run -it centos /bin/bash [root@a8b5df0d1e9c /]# 这个容器内部也是一个小型的服务器环境 [root@iz8g9301trfnpxz /]# docker run -it centos /bin/bash [root@a8b5df0d1e9c /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var 内部的centos和外部的centos没有半毛钱关系 很多命令都是不完善的 从容器中退出主机 [root@a8b5df0d1e9c /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@a8b5df0d1e9c /]# exit exit [root@iz8g9301trfnpxz /]# 列出所有的运行的容器 # docker ps 命令 # 列出当前正在运行的容器 -a # 列出当前运行的容器+列出曾经的运行的容器 -n=? # 显示出容器 试一下 [root@iz8g9301trfnpxz /]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@iz8g9301trfnpxz /]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a8b5df0d1e9c centos \"/bin/bash\" 2 minutes ago Exited (0) 46 seconds ago romantic_hawking 370f3dcf3c32 bf756fb1ae65 \"/hello\" About an hour ago Exited (0) About an hour ago elated_fermi 289fedfe164c bf756fb1ae65 \"/hello\" About an hour ago Exited (0) About an hour ago goofy_brahmagupta 整个docker 就如何围绕着容器和镜像来打交道 退出容器 exit # 直接容器停止并退出 Ctrl+P+Q # 容器不停止退出 删除容器 docker rm docker rm -f $(docker ps -aq) docker ps -a -q|xargs docker rm # 删除所有的容器 启动和停止容器的操作 docker start 容器id # 启动容器 docker restart 容器id # 重启容器 docker stop 容器id # 停止当前正在运行的容器 docker kill 容器id # 强制停止当前容器 从容器内拷贝文件到主机上 docker cp 容器id: 容器内路径 目的的主机路径 [root@iz8g9301trfnpxz home]# docker attach 1a9d611cdabb [root@1a9d611cdabb /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@1a9d611cdabb /]# cd home [root@1a9d611cdabb home]# ls [root@1a9d611cdabb home]# [root@1a9d611cdabb home]# touch test.java [root@1a9d611cdabb home]# exit [root@iz8g9301trfnpxz home]# docker cp 1a9d611cdabb:/home/test.java /home [root@iz8g9301trfnpxz home]# ls admin kuangshen.java test.java 拷贝是一个手动过程,未来我们使用 -v 卷技术 可以实现 学习方式: 将我们所有命令全部敲一遍,记住new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:56:23 "},"base/2020-07-11-docker_常用其他命令.html":{"url":"base/2020-07-11-docker_常用其他命令.html","title":"常用其他命令","keywords":"","body":"常用其他命令 后台启动容器 # 命令 docker run -d 镜像名 [root@iz8g9301trfnpxz /]# docker run -d centos # 问题docker ps ,发现 centos 停止了 # 常见的坑: docker 容器使用后台运行,就必须要有一个前台进程,docker发现没有应用,就会自动停止 # nginx ,容器启动,发现自己没有提供服务,就会立刻停止 试一下 [root@iz8g9301trfnpxz /]# docker run -d centos 943076a33a4abedb7fa35edcd0a666bcbc42106687d9a08c93cda19ec6a2d614 [root@iz8g9301trfnpxz /]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@iz8g9301trfnpxz /]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 943076a33a4a centos \"/bin/bash\" 17 seconds ago Exited (0) 16 seconds ago condescending_swanson [root@iz8g9301trfnpxz /]# 查看日志信息 docker logs -f -t --tail 容器,没有日志 # 自己编写一段shell脚本 \"while true;do echo kuangshen; sleep 1;done\" 试一下 [root@iz8g9301trfnpxz /]# docker run -d centos /bin/sh -c \"while true;do echo kuangshen;sleep 1;done\" 34b4cedd8004fcace48fb07d6802d57a877198f774bfcacf4346b2eec76f07ff [root@iz8g9301trfnpxz /]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 34b4cedd8004 centos \"/bin/sh -c 'while t…\" 2 seconds ago Up 2 seconds romantic_chaum [root@iz8g9301trfnpxz /]# 显示日志 # 显示日志 [root@iz8g9301trfnpxz /]# docker logs --help Usage: docker logs [OPTIONS] CONTAINER Fetch the logs of a container Options: --details Show extra details provided to logs -f, --follow Follow log output --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) --tail string Number of lines to show from the end of the logs (default \"all\") -t, --timestamps Show timestamps --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) 试一下 [root@iz8g9301trfnpxz /]# docker logs -tf --tail 10 34b4cedd8004 2020-07-30T08:53:17.655205690Z kuangshen 2020-07-30T08:53:18.656619085Z kuangshen 2020-07-30T08:53:19.658266901Z kuangshen 2020-07-30T08:53:20.660107094Z kuangshen 2020-07-30T08:53:21.661694675Z kuangshen 2020-07-30T08:53:22.663298835Z kuangshen 2020-07-30T08:53:23.664697145Z kuangshen 2020-07-30T08:53:24.666458660Z kuangshen 2020-07-30T08:53:25.668670898Z kuangshen 2020-07-30T08:53:26.670725103Z kuangshen 查看容器信息 docker ps 查看容器中进程信息 docker top 容器id 试一下 [root@iz8g9301trfnpxz /]# docker top 34b4cedd8004 UID PID PPID C STIME TTY TIME CMD root 7638 7614 0 16:51 ? 00:00:00 /bin/sh -c while true;do echo kuangshen;sleep 1;done root 8106 7638 0 16:56 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1 查看镜像元数据 docker inspect --help 试一下 ```shell [root@iz8g9301trfnpxz /]# docker inspect 95d169e1c512 [ { \"Id\": \"95d169e1c512f2b6bd0b56451d01c1f21a3fd272c6ea5dc25d2c787c2613e925\", \"Created\": \"2020-07-30T08:45:42.71549164Z\", \"Path\": \"/bin/bash\", \"Args\": [], \"State\": { \"Status\": \"exited\", \"Running\": false, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 0, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2020-07-30T08:45:43.130301643Z\", \"FinishedAt\": \"2020-07-30T08:50:48.572418052Z\" }, \"Image\": \"sha256:831691599b88ad6cc2a4abbd0e89661a121aff14cfa289ad840fd3946f274f1f\", \"ResolvConfPath\": \"/var/lib/docker/containers/95d169e1c512f2b6bd0b56451d01c1f21a3fd272c6ea5dc25d2c787c2613e925/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/95d169e1c512f2b6bd0b56451d01c1f21a3fd272c6ea5dc25d2c787c2613e925/hostname\", \"HostsPath\": \"/var/lib/docker/containers/95d169e1c512f2b6bd0b56451d01c1f21a3fd272c6ea5dc25d2c787c2613e925/hosts\", \"LogPath\": \"/var/lib/docker/containers/95d169e1c512f2b6bd0b56451d01c1f21a3fd272c6ea5dc25d2c787c2613e925/95d169e1c512f2b6bd0b56451d01c1f21a3fd272c6ea5dc25d2c787c2613e925-json.log\", \"Name\": \"/quizzical_feynman\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"MountLabel\": \"\", \"ProcessLabel\": \"\", \"AppArmorProfile\": \"\", \"ExecIDs\": null, \"HostConfig\": { \"Binds\": null, \"ContainerIDFile\": \"\", \"LogConfig\": { \"Type\": \"json-file\", \"Config\": {} }, \"NetworkMode\": \"default\", \"PortBindings\": {}, \"RestartPolicy\": { \"Name\": \"no\", \"MaximumRetryCount\": 0 }, \"AutoRemove\": false, \"VolumeDriver\": \"\", \"VolumesFrom\": null, \"CapAdd\": null, \"CapDrop\": null, \"Capabilities\": null, \"Dns\": [], \"DnsOptions\": [], \"DnsSearch\": [], \"ExtraHosts\": null, \"GroupAdd\": null, \"IpcMode\": \"private\", \"Cgroup\": \"\", \"Links\": null, \"OomScoreAdj\": 0, \"PidMode\": \"\", \"Privileged\": false, \"PublishAllPorts\": false, \"ReadonlyRootfs\": false, \"SecurityOpt\": null, \"UTSMode\": \"\", \"UsernsMode\": \"\", \"ShmSize\": 67108864, \"Runtime\": \"runc\", \"ConsoleSize\": [ 0, 0 ], \"Isolation\": \"\", \"CpuShares\": 0, \"Memory\": 0, \"NanoCpus\": 0, \"CgroupParent\": \"\", \"BlkioWeight\": 0, \"BlkioWeightDevice\": [], \"BlkioDeviceReadBps\": null, \"BlkioDeviceWriteBps\": null, \"BlkioDeviceReadIOps\": null, \"BlkioDeviceWriteIOps\": null, \"CpuPeriod\": 0, \"CpuQuota\": 0, \"CpuRealtimePeriod\": 0, \"CpuRealtimeRuntime\": 0, \"CpusetCpus\": \"\", \"CpusetMems\": \"\", \"Devices\": [], \"DeviceCgroupRules\": null, \"DeviceRequests\": null, \"KernelMemory\": 0, \"KernelMemoryTCP\": 0, \"MemoryReservation\": 0, \"MemorySwap\": 0, \"MemorySwappiness\": null, \"OomKillDisable\": false, \"PidsLimit\": null, \"Ulimits\": null, \"CpuCount\": 0, \"CpuPercent\": 0, \"IOMaximumIOps\": 0, \"IOMaximumBandwidth\": 0, \"MaskedPaths\": [ \"/proc/asound\", \"/proc/acpi\", \"/proc/kcore\", \"/proc/keys\", \"/proc/latency_stats\", \"/proc/timer_list\", \"/proc/timer_stats\", \"/proc/sched_debug\", \"/proc/scsi\", \"/sys/firmware\" ], \"ReadonlyPaths\": [ \"/proc/bus\", \"/proc/fs\", \"/proc/irq\", \"/proc/sys\", \"/proc/sysrq-trigger\" ] }, \"GraphDriver\": { \"Data\": { \"LowerDir\": \"/var/lib/docker/overlay2/3d017146d9a1a4a24cf16ad75bb151daede84629958ed97a6539c05b3a74ecb3-init/diff:/var/lib/docker/overlay2/7be18956fd4a8679af67244a0bb9d19b4abc7e060c5712ce24bf3489c93ea32b/diff\", \"MergedDir\": \"/var/lib/docker/overlay2/3d017146d9a1a4a24cf16ad75bb151daede84629958ed97a6539c05b3a74ecb3/merged\", \"UpperDir\": \"/var/lib/docker/overlay2/3d017146d9a1a4a24cf16ad75bb151daede84629958ed97a6539c05b3a74ecb3/diff\", \"WorkDir\": \"/var/lib/docker/overlay2/3d017146d9a1a4a24cf16ad75bb151daede84629958ed97a6539c05b3a74ecb3/work\" }, \"Name\": \"overlay2\" }, \"Mounts\": [], \"Config\": { \"Hostname\": \"95d169e1c512\", \"Domainname\": \"\", \"User\": \"\", \"AttachStdin\": true, \"AttachStdout\": true, \"AttachStderr\": true, \"Tty\": true, \"OpenStdin\": true, \"StdinOnce\": true, \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ], \"Cmd\": [ \"/bin/bash\" ], \"Image\": \"centos\", \"Volumes\": null, \"WorkingDir\": \"\", \"Entrypoint\": null, \"OnBuild\": null, \"Labels\": { \"org.label-schema.build-date\": \"20200611\", \"org.label-schema.license\": \"GPLv2\", \"org.label-schema.name\": \"CentOS Base Image\", \"org.label-schema.schema-version\": \"1.0\", \"org.label-schema.vendor\": \"CentOS\" } }, \"NetworkSettings\": { \"Bridge\": \"\", \"SandboxID\": \"9755224587a3dc686401019552178df9a997f681ad7061b90e4abbee98e3e51a\", \"HairpinMode\": false, \"LinkLocalIPv6Address\": \"\", \"LinkLocalIPv6PrefixLen\": 0, \"Ports\": {}, \"SandboxKey\": \"/var/run/docker/netns/9755224587a3\", \"SecondaryIPAddresses\": null, \"SecondaryIPv6Addresses\": null, \"EndpointID\": \"\", \"Gateway\": \"\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"IPAddress\": \"\", \"IPPrefixLen\": 0, \"IPv6Gateway\": \"\", \"MacAddress\": \"\", \"Networks\": { \"bridge\": { \"IPAMConfig\": null, \"Links\": null, \"Aliases\": null, \"NetworkID\": \"68c30b64280cd79fbbee1895f55c67d9febdb11a032fcbd4326319b1ea5c5075\", \"EndpointID\": \"\", \"Gateway\": \"\", \"IPAddress\": \"\", \"IPPrefixLen\": 0, \"IPv6Gateway\": \"\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"MacAddress\": \"\", \"DriverOpts\": null } } } } ] ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:44:42 "},"base/2020-07-12-docker_进入容器的命令.html":{"url":"base/2020-07-12-docker_进入容器的命令.html","title":"进入容器的命令","keywords":"","body":"进入容器命令 我们通常容器都是使用后台的方式运行的,需要进入容器,修改一些配置 # 命令 docker exec -it 容器 id bashshell 比如 [root@iz8g9301trfnpxz ~]# docker exec -it 34b4cedd8004 /bin/bash [root@34b4cedd8004 /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var 方式2 docker exec # 进入容器后开启一个新的终端,可以在里面操作(常用) docker attach # 进入容器正在执行的终端,不会启动新的进程 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:56:23 "},"base/2020-07-13-docker_常用命令小结.html":{"url":"base/2020-07-13-docker_常用命令小结.html","title":"常用命令小结","keywords":"","body":"常用命令小结常用命令小结 具体的命令是十分多的,上面我们学习的都是最常用的容器和镜像命令,之后我们还会学习很多命令 接下来就是一堆的练习 https://www.cnblogs.com/DeepInThought/p/10896790.html https://www.cnblogs.com/duanxz/p/7905233.html https://www.runoob.com/docker/docker-command-manual.html new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-12 19:53:49 "},"base/2020-07-14-docker_部署nginx.html":{"url":"base/2020-07-14-docker_部署nginx.html","title":"部署nginx","keywords":"","body":"作业1:部署nginxdocker 安装nginx作业2:使用docker来装一个tomcatnew Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false})作业1:部署nginx docker 安装nginx # 1.搜索镜像 search 建议大家去docker hub上面去搜索 # 2.下载镜像 pull 试一下 [root@iz8g9301trfnpxz home]# docker pull nginx Using default tag: latest latest: Pulling from library/nginx 6ec8c9369e08: Pull complete d3cb09a117e5: Pull complete 7ef2f1459687: Pull complete e4d1bf8c9482: Pull complete 795301d236d7: Pull complete Digest: sha256:0e188877aa60537d1a1c6484b8c3929cfe09988145327ee47e8e91ddf6f76f5c Status: Downloaded newer image for nginx:latest docker.io/library/nginx:latest # -d 后台运行 # -name 起名字 # -p 宿主机端口对应的里面的端口 端口暴漏 映射 [root@iz8g9301trfnpxz home]# docker run -d --name nginx01 -p 3344:80 nginx f9277b55c181bd12515f53953c82ac8514879a16da9e14968f35923dca5b0537 [root@iz8g9301trfnpxz home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f9277b55c181 nginx \"/docker-entrypoint.…\" 4 seconds ago Up 3 seconds 0.0.0.0:3344->80/tcp nginx01 [root@iz8g9301trfnpxz home]# curl curl: try 'curl --help' or 'curl --manual' for more information [root@iz8g9301trfnpxz home]# curl localhost:3344 Welcome to nginx! body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx. [root@iz8g9301trfnpxz home]# 端口暴漏的概念 思考问题: 我们每次改动nginx配置文件,都需要进入容器内部?十分麻烦,我要是可以在容器外部提供一个映射路径,达到在容器外部修改文件,容器内部就可以自动更改,那就NB了 作业2:使用docker来装一个tomcatnew Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:56:23 "},"base/2020-07-15-docker_部署tomcat.html":{"url":"base/2020-07-15-docker_部署tomcat.html","title":"部署tomcat","keywords":"","body":"作业2:使用docker来装一个tomcat作业2:使用docker来装一个tomcat # 官方的使用 docker run -it --rm tomcat:9.0 # 我们之前的启动都是后台,停止了容器之后,容器还是可以查到 docker run -it --rm ,一般用于测试,用完即删除 # 先下载 在启动 docker pull tomcat:9.0 # 启动运行 docker run -d -p 3355:8080 --name tomcat01 tomcat # 测试访问没有问题 root@f1421fbdf093:/usr/local/tomcat# ls BUILDING.txt LICENSE README.md RUNNING.txt conf logs temp webapps.dist CONTRIBUTING.md NOTICE RELEASE-NOTES bin lib native-jni-lib webapps work root@f1421fbdf093:/usr/local/tomcat# cd webapps root@f1421fbdf093:/usr/local/tomcat/webapps# l # 进入容器 [root@iz8g9301trfnpxz home]# docker exec -it tomcat01 /bin/bash # 发现问题:1,linux 命令少了,2.没有webapps .阿里云镜像的原因,他使用最小的 思考问题:我们每次进入容器十分麻烦,如果要是可以在容器外部提供一个映射路径,然后能够在我们的外部放置项目,就自动同步到内容就好了! docker 容器 tomcat mysql放到docker 不科学 删掉容器就能够删库跑路了new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:56:23 "},"base/2020-07-16-docker_部署es.html":{"url":"base/2020-07-16-docker_部署es.html","title":"部署es","keywords":"","body":"作业3:部署es+kibana使用kibana连接elasticsearch title: \"Docker部署elasticsearch\" tags: docker 作业3:部署es+kibana # es暴漏的端口很多 # es 十分耗内存 # es 的数据一般需要放置到安全目录 # 官方这么写的 # 启动elasticsearch docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.6.2 # --net somenetwork # 启动了 linux就卡住了 docker stats # 查看cpu状态 # es是十分耗内存的 1核2G 现在他是启动不起来了 # 停止我们的docker # 测试一下es是否 # 增加内存的操作 # 赶紧关闭 docker run -d --name elasticsearch -p 9200:9200 -p -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" elasticsearch:7.6.2 这回再试试 [root@iz8g9301trfnpxz home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f9277b55c181 nginx \"/docker-entrypoint.…\" 36 minutes ago Up 36 minutes 0.0.0.0:3344->80/tcp nginx01 [root@iz8g9301trfnpxz home]# docker stop f9277b55c181 f9277b55c181 [root@iz8g9301trfnpxz home]# docker run -d --name elasticsearch02 -p 9200:9200 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" elasticsearch:7.6.2 f693ce46235c8b7a4106cda033e9e6211ffc0f978457be3ccf72abe23acac24a [root@iz8g9301trfnpxz home]# docker stats CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 0.05% 204.9MiB / 1.796GiB 11.14% 0B / 0B 0B / 0B 19 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 0.05% 204.9MiB / 1.796GiB 11.14% 0B / 0B 0B / 0B 19 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 98.78% 226.2MiB / 1.796GiB 12.30% 0B / 0B 0B / 0B 19 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 98.78% 226.2MiB / 1.796GiB 12.30% 0B / 0B 0B / 0B 19 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 98.14% 233.3MiB / 1.796GiB 12.68% 0B / 0B 0B / 0B 19 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 98.14% 233.3MiB / 1.796GiB 12.68% 0B / 0B 0B / 0B 19 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 99.96% 244.5MiB / 1.796GiB 13.29% 0B / 0B 0B / 0B 19 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 99.96% 244.5MiB / 1.796GiB 13.29% 0B / 0B 0B / 0B 19 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 97.79% 253.4MiB / 1.796GiB 13.78% 0B / 0B 0B / 0B 19 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 97.79% 253.4MiB / 1.796GiB 13.78% 0B / 0B 0B / 0B 19 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 98.67% 266.3MiB / 1.796GiB 14.47% 0B / 0B 0B / 0B 20 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 98.67% 266.3MiB / 1.796GiB 14.47% 0B / 0B 0B / 0B 20 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 99.21% 270.3MiB / 1.796GiB 14.70% 0B / 0B 0B / 0B 20 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 99.21% 270.3MiB / 1.796GiB 14.70% 0B / 0B 0B / 0B 20 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 95.08% 276.7MiB / 1.796GiB 15.04% 0B / 0B 0B / 0B 26 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS f693ce46235c elasticsearch02 95.08% 276.7MiB / 1.796GiB 15.04% 0B / 0B 0B / 0B 26 ^C [root@iz8g9301trfnpxz home]# clear [root@iz8g9301trfnpxz home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f693ce46235c elasticsearch:7.6.2 \"/usr/local/bin/dock…\" 27 seconds ago Up 26 seconds 0.0.0.0:9200->9200/tcp, 9300/tcp elasticsearch02 [root@iz8g9301trfnpxz home]# curl localhost:9200 { \"name\" : \"f693ce46235c\", \"cluster_name\" : \"docker-cluster\", \"cluster_uuid\" : \"woaoctzxSoWCx_ksjXFTbg\", \"version\" : { \"number\" : \"7.6.2\", \"build_flavor\" : \"default\", \"build_type\" : \"docker\", \"build_hash\" : \"ef48eb35cf30adf4db14086e8aabd07ef6fb113f\", \"build_date\" : \"2020-03-26T06:34:37.794943Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.4.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\" } [root@iz8g9301trfnpxz home]# 使用kibana连接elasticsearch new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:56:23 "},"base/2020-07-17-docker_使用kibana连接es.html":{"url":"base/2020-07-17-docker_使用kibana连接es.html","title":"使用kibana连接es","keywords":"","body":"使用kibana连接elasticsearch使用kibana连接elasticsearch docker 网络原理 网络基本知识 思考网络如何能够连接过去 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:57:12 "},"base/2020-07-18-docker_可视化面板安装.html":{"url":"base/2020-07-18-docker_可视化面板安装.html","title":"可视化面板安装","keywords":"","body":"使用portainer(先用这个)什么是portainer使用portainer(先用这个) docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 什么是portainer docker 图形化界面管理工具! 提供了一个后台面板供我们操作! docker run -d -p 8088:9000 portainer/portainer # 访问测试:外网 8088 # 通过它来访问 我们通常不用这个东东 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:56:23 "},"base/2020-07-19-docker_镜像原理之联合文件系统.html":{"url":"base/2020-07-19-docker_镜像原理之联合文件系统.html","title":"镜像原理之联合文件系统","keywords":"","body":"镜像原理之联合文件系统镜像原理之联合文件系统 Docker 镜像讲解 镜像是什么 镜像是一种轻量级,可执行的独立软件包,用来打包软件运行环境和基于运行环境开发的软件,它包含运行某个软件所需的所有内容,包括代码、运行时,库,环境变量好而配置文件. 所有的应用,直接打包docker镜像,就可以直接跑起来! 如何得到镜像: 从远程仓库下载 朋友拷贝 自己制作DockerFile new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-12 19:53:49 "},"base/2020-07-20-docker_镜像原理之分层理解.html":{"url":"base/2020-07-20-docker_镜像原理之分层理解.html","title":"镜像原理之分层理解","keywords":"","body":"镜像原理之分层镜像原理之分层 你以为你在第一层,其实你在第3层 分层能够文件复用 每个层级之间互相不影响 https://www.cnblogs.com/handwrit2000/p/12871493.html https://www.jb51.net/article/175913.htm https://recomm.cnblogs.com/blogpost/12871493 https://blog.csdn.net/weixin_34349320/article/details/92244228 https://www.cnblogs.com/sammyliu/p/5931383.html https://www.cnblogs.com/breezey/p/9589288.htmlnew Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-12 19:53:49 "},"base/2020-07-21-docker_commit镜像.html":{"url":"base/2020-07-21-docker_commit镜像.html","title":"commit镜像","keywords":"","body":"commit镜像后面没讲的commit镜像 docker commit 提交容器成为一个新的副本 # 命令和git原理类似 docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名:[TAG] 实战 [root@iz8g9301trfnpxz ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 48d9ea6fdb71 tomcat \"catalina.sh run\" 4 minutes ago Up 4 minutes 0.0.0.0:8080->8080/tcp interesting_almeida [root@iz8g9301trfnpxz ~]# docker commit -a=\"victor\" -m\"add webapps app\" 48d9ea6fdb71 tomcat02:1.0 sha256:b17b415625d5ba90d1110824b0b3fe407d214945b2a20cefba3add4d060d027d [root@iz8g9301trfnpxz ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 b17b415625d5 7 seconds ago 657MB tomcat latest 9a9ad4f631f8 46 hours ago 647MB portainer/portainer latest 62771b0b9b09 8 days ago 79.1MB nginx latest 8cf1bfb43ff5 8 days ago 132MB redis latest 50541622f4f1 8 days ago 104MB centos latest 831691599b88 6 weeks ago 215MB elasticsearch 7.6.2 f29a1ee41030 4 months ago 791MB elasticsearch latest 5acf0e8da90b 22 months ago 486MB # 1. 启动一个默认的tomcat # 2. 发现这个默认的tomcat是没有webapps应用,镜像的原因,官方的镜像默认webapps下面是没有文件的! # 3. 我自己拷贝进去基本的文件 # 4. 将我们操作过的容器通过commit提交为一个镜像!我们以后就使用我们修改过的镜像即可,这就是我们自己的一个修改的镜像 学习方式说明:理解概念,但是一定要实践,最后实践与理论想结合一次搞定这个知识 # 如果你想要保存当前容器的状态,就可以通过commit 提交,获得一个镜像 # 就好比我们以前学习vm时候,快照 到了这里才算是入门docker! 认真吸收练习 后面没讲的 容器数据卷 DockerFile Docker网络 企业实战 Docker Compose Docker Swarm CI/CD Jenkins 流水线!!!new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:56:23 "},"base/2020-07-22-docker_容器数据卷.html":{"url":"base/2020-07-22-docker_容器数据卷.html","title":"容器数据卷","keywords":"","body":"容器数据卷使用数据卷容器数据卷 什么是容器数据卷 docker 的理念回顾 将应用和环境打包成一个镜像 数据?如果数据都在容器中,那么我们容器删除,数据都会丢失===需求===:数据可以持久化 MySQL,容器删了,MySQL里面的数据会跟着一块儿丢,这个删库跑路的风险就非常大 需求: MySQL数据可以存储在本地! 容器之间可以有一个数据共享的技术! Docker 容器中产生的数据,同步到本地! 这就是咱们的卷技术!!! 说白了就是目录的挂载,将我么容器内的目录,挂载到Linux上面! 同步机制 总结一句话:容器的持久化和同步操作! 容器间也是可以数据共享的! 使用数据卷 # 方式1 直接使用命令挂载 -v docker run -it -v 主机目录: 容器内目录 实践一下 [root@iz8g9301trfnpxz ~]# cd /home [root@iz8g9301trfnpxz home]# ls admin kuangshen.java test.java [root@iz8g9301trfnpxz home]# docker run -it -v /home/ceshi:/home centos /bin/bash 查看外面有没有,果然 [root@iz8g9301trfnpxz home]# ls admin ceshi kuangshen.java test.java 好处,我们以后修改只需要在本地修改即可,容器内部会自动同步new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:56:23 "},"base/2020-07-23-docker_容器数据卷2.html":{"url":"base/2020-07-23-docker_容器数据卷2.html","title":"容器数据卷2","keywords":"","body":"实战安装MySQL实战安装MySQL 思考:MySQL的数据持久化问题 docker # 获取镜像 # 运行容器,需要做数据挂载! # 安装启动mysql,需要配置密码的,这是要注意的问题 # 官方的测试 # 启动我们的 -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 --name 容器名字 docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 启动成功之后,我们在本地使用 idea来连接测试一下 idea连接到服务器的3310-> docker 内的 3306映射,这个时候我们就可以连接上了 在本地测试数据库创建一个数据库,查看我们映射的路径是否ok! 假设我们将容器删除 发现,我们挂载到本地的数据卷依旧没有丢失,这就是实现了容器数据的持久化功能new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:56:23 "},"base/2020-07-24-docker_具名挂载和匿名挂载.html":{"url":"base/2020-07-24-docker_具名挂载和匿名挂载.html","title":"具名挂载和匿名挂载","keywords":"","body":"具名挂载和匿名挂载具名挂载和匿名挂载 # 匿名挂载 -v 容器内路径! docker run -d -P --name nginx01 -v /etc/nginx nginx # 查看所有卷的情况 [root@iz8g9301trfnpxz data]# docker volume ls # 这里发现 DRIVER VOLUME NAME local 779306d85877e4a2ebacb40e6c4bfea39e1c6123edde1eec7273d5cb445801d4 # 这种就是咱们的匿名挂载,我们在-v 只写了容器内的路径,没有写外部的路径 # 具名挂载 [root@iz8g9301trfnpxz data]# docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx nginx 33d87d73cf81951d8cdede7b02f1454c20c39864a182f5cd3072b010f22c5451 [root@iz8g9301trfnpxz data]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 33d87d73cf81 nginx \"/docker-entrypoint.…\" 6 seconds ago Up 5 seconds 0.0.0.0:32769->80/tcp nginx03 8ec30de68329 nginx \"/docker-entrypoint.…\" 3 minutes ago Up 3 minutes 0.0.0.0:32768->80/tcp nginx02 [root@iz8g9301trfnpxz data]# docker volume ls DRIVER VOLUME NAME local 779306d85877e4a2ebacb40e6c4bfea39e1c6123edde1eec7273d5cb445801d4 local a4481d7a0fec6c3af8bd2c17be14e2e48b7c3b9debb3a99c498c44ec135519b6 local abe53729eb4d2a97c8d8c52c3b00cb094a7dc5490435b8f27dcc03599931e302 local juming-nginx [root@iz8g9301trfnpxz data]# # 通过-v 卷名 :容器内路径 # 通过 # docker volume inspect # 查看一下这个卷 [root@iz8g9301trfnpxz data]# docker volume inspect juming-nginx [ { \"CreatedAt\": \"2020-07-31T10:21:13+08:00\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/juming-nginx/_data\", \"Name\": \"juming-nginx\", \"Options\": null, \"Scope\": \"local\" } ] [root@iz8g9301trfnpxz data]# # 所有的docker容器你的卷,没有指定目录的情况下都是在`/var/lib/docker/volumes/xxx/_data # 我们通过具名挂载可以方便的找到我们的一个卷,大多数情况在使用的`具名挂载` # 如何确定是具名挂载还是匿名挂载,还是指定路径挂载 -v 容器内路径 # 匿名挂载 -v 卷名 : 容器内路径 # 具名挂载 -v /宿主机路径: 容器内路径 # 指定路径挂载 拓展 # 通过 -v 容器内路径: ro rw 改变读写权限 ro readonly rw readwrite # 一旦这个了设置了容器权限,容器对我们挂载出来的内容就有限定了! docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx # ro 说明这个路径只能通过宿主机操作,容器内部是无法操作的 操作 初始dockerfile new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:56:23 "},"base/2020-07-25-docker_初始dockerfile.html":{"url":"base/2020-07-25-docker_初始dockerfile.html","title":"初始dockerfile","keywords":"","body":"初始dockerfile数据卷容器初始dockerfile dockerfile 就是用来构建docker镜像的构建文件!命令脚本! 先体验一下! # 通过这脚本可以生成一个镜像,镜像是一层一层的,脚本是一个个命令,每个命令都是一层 # 创建一个dockerfile文件,名字可以随机 建议dockerfile # 文件中的内容指令(大写) 参数 FROM centos VOLUME [\"volume01\",\"volume02\"] CMD echo \"------end------\" CMD /bin/bash/ # 这里的每一个命令都是镜像的一层 试一下 [root@iz8g9301trfnpxz docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t kuangshen/centos:1.0 . Sending build context to Docker daemon 2.048kB Step 1/4 : FROM centos ---> 831691599b88 Step 2/4 : VOLUME [\"volume01\",\"volume02\"] ---> Running in cfe1a7c20843 Removing intermediate container cfe1a7c20843 ---> e0877f9a102a Step 3/4 : CMD echo \"------end------\" ---> Running in 4ba75004d5d0 Removing intermediate container 4ba75004d5d0 ---> 04b1dbef792a Step 4/4 : CMD /bin/bash/ ---> Running in 94b3954a4d3e Removing intermediate container 94b3954a4d3e ---> 5c7e025fc4ff Successfully built 5c7e025fc4ff Successfully tagged kuangshen/centos:1.0 [root@iz8g9301trfnpxz docker-test-volume]# 启动一下自己写的容器 [root@iz8g9301trfnpxz docker-test-volume]# clear [root@iz8g9301trfnpxz docker-test-volume]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE kuangshen/centos 1.0 5c7e025fc4ff 5 minutes ago 215MB tomcat02 1.0 b17b415625d5 2 hours ago 657MB tomcat latest 9a9ad4f631f8 2 days ago 647MB portainer/portainer latest 62771b0b9b09 8 days ago 79.1MB mysql 5.7 8679ced16d20 8 days ago 448MB nginx latest 8cf1bfb43ff5 8 days ago 132MB redis latest 50541622f4f1 9 days ago 104MB centos latest 831691599b88 6 weeks ago 215MB elasticsearch 7.6.2 f29a1ee41030 4 months ago 791MB elasticsearch latest 5acf0e8da90b 22 months ago 486MB [root@iz8g9301trfnpxz docker-test-volume]# docker run -it 5c7e025fc4ff /bin/bash [root@1e52e32ab8e7 /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var volume01 volume02 上面的volume01和volume02就是我们自己挂载的,这个卷和外部一定是有一个同步的 [root@iz8g9301trfnpxz home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1e52e32ab8e7 5c7e025fc4ff \"/bin/bash\" 2 minutes ago Up 2 minutes goofy_feistel 33d87d73cf81 nginx \"/docker-entrypoint.…\" 25 minutes ago Up 25 minutes 0.0.0.0:32769->80/tcp nginx03 8ec30de68329 nginx \"/docker-entrypoint.…\" 28 minutes ago Up 28 minutes 0.0.0.0:32768->80/tcp nginx02 [root@iz8g9301trfnpxz home]# docker inspect 1e52e32ab8e7 [ { \"Id\": \"1e52e32ab8e7c00c87346c65bb75915dc4cfa557c03a78ae9cdb30fa2d6f125f\", \"Created\": \"2020-07-31T02:44:24.621394005Z\", \"Path\": \"/bin/bash\", \"Args\": [], \"State\": { \"Status\": \"running\", \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 1318, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2020-07-31T02:44:24.951669958Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, \"Image\": \"sha256:5c7e025fc4ff374c40b48eba10fccfeb6c6e00fb5499837e76755f8d22927229\", \"ResolvConfPath\": \"/var/lib/docker/containers/1e52e32ab8e7c00c87346c65bb75915dc4cfa557c03a78ae9cdb30fa2d6f125f/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/1e52e32ab8e7c00c87346c65bb75915dc4cfa557c03a78ae9cdb30fa2d6f125f/hostname\", \"HostsPath\": \"/var/lib/docker/containers/1e52e32ab8e7c00c87346c65bb75915dc4cfa557c03a78ae9cdb30fa2d6f125f/hosts\", \"LogPath\": \"/var/lib/docker/containers/1e52e32ab8e7c00c87346c65bb75915dc4cfa557c03a78ae9cdb30fa2d6f125f/1e52e32ab8e7c00c87346c65bb75915dc4cfa557c03a78ae9cdb30fa2d6f125f-json.log\", \"Name\": \"/goofy_feistel\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"MountLabel\": \"\", \"ProcessLabel\": \"\", \"AppArmorProfile\": \"\", \"ExecIDs\": null, \"HostConfig\": { \"Binds\": null, \"ContainerIDFile\": \"\", \"LogConfig\": { \"Type\": \"json-file\", \"Config\": {} }, \"NetworkMode\": \"default\", \"PortBindings\": {}, \"RestartPolicy\": { \"Name\": \"no\", \"MaximumRetryCount\": 0 }, \"AutoRemove\": false, \"VolumeDriver\": \"\", \"VolumesFrom\": null, \"CapAdd\": null, \"CapDrop\": null, \"Capabilities\": null, \"Dns\": [], \"DnsOptions\": [], \"DnsSearch\": [], \"ExtraHosts\": null, \"GroupAdd\": null, \"IpcMode\": \"private\", \"Cgroup\": \"\", \"Links\": null, \"OomScoreAdj\": 0, \"PidMode\": \"\", \"Privileged\": false, \"PublishAllPorts\": false, \"ReadonlyRootfs\": false, \"SecurityOpt\": null, \"UTSMode\": \"\", \"UsernsMode\": \"\", \"ShmSize\": 67108864, \"Runtime\": \"runc\", \"ConsoleSize\": [ 0, 0 ], \"Isolation\": \"\", \"CpuShares\": 0, \"Memory\": 0, \"NanoCpus\": 0, \"CgroupParent\": \"\", \"BlkioWeight\": 0, \"BlkioWeightDevice\": [], \"BlkioDeviceReadBps\": null, \"BlkioDeviceWriteBps\": null, \"BlkioDeviceReadIOps\": null, \"BlkioDeviceWriteIOps\": null, \"CpuPeriod\": 0, \"CpuQuota\": 0, \"CpuRealtimePeriod\": 0, \"CpuRealtimeRuntime\": 0, \"CpusetCpus\": \"\", \"CpusetMems\": \"\", \"Devices\": [], \"DeviceCgroupRules\": null, \"DeviceRequests\": null, \"KernelMemory\": 0, \"KernelMemoryTCP\": 0, \"MemoryReservation\": 0, \"MemorySwap\": 0, \"MemorySwappiness\": null, \"OomKillDisable\": false, \"PidsLimit\": null, \"Ulimits\": null, \"CpuCount\": 0, \"CpuPercent\": 0, \"IOMaximumIOps\": 0, \"IOMaximumBandwidth\": 0, \"MaskedPaths\": [ \"/proc/asound\", \"/proc/acpi\", \"/proc/kcore\", \"/proc/keys\", \"/proc/latency_stats\", \"/proc/timer_list\", \"/proc/timer_stats\", \"/proc/sched_debug\", \"/proc/scsi\", \"/sys/firmware\" ], \"ReadonlyPaths\": [ \"/proc/bus\", \"/proc/fs\", \"/proc/irq\", \"/proc/sys\", \"/proc/sysrq-trigger\" ] }, \"GraphDriver\": { \"Data\": { \"LowerDir\": \"/var/lib/docker/overlay2/b788b8fbe178271f742f242cd0cdced934cb5d4c004fe5fb6af6e7c03ac7a15c-init/diff:/var/lib/docker/overlay2/7be18956fd4a8679af67244a0bb9d19b4abc7e060c5712ce24bf3489c93ea32b/diff\", \"MergedDir\": \"/var/lib/docker/overlay2/b788b8fbe178271f742f242cd0cdced934cb5d4c004fe5fb6af6e7c03ac7a15c/merged\", \"UpperDir\": \"/var/lib/docker/overlay2/b788b8fbe178271f742f242cd0cdced934cb5d4c004fe5fb6af6e7c03ac7a15c/diff\", \"WorkDir\": \"/var/lib/docker/overlay2/b788b8fbe178271f742f242cd0cdced934cb5d4c004fe5fb6af6e7c03ac7a15c/work\" }, \"Name\": \"overlay2\" }, \"Mounts\": [ { \"Type\": \"volume\", \"Name\": \"e113c26dfe915b20080e5a9f7ae700713d4f443ca95b9e80d82d351ace6b88ca\", \"Source\": \"/var/lib/docker/volumes/e113c26dfe915b20080e5a9f7ae700713d4f443ca95b9e80d82d351ace6b88ca/_data\", \"Destination\": \"volume02\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" }, { \"Type\": \"volume\", \"Name\": \"b78af0b69e7fdfa0c87d2247f895021f6772b52e0d57b0f6ac3bef66dfd58964\", \"Source\": \"/var/lib/docker/volumes/b78af0b69e7fdfa0c87d2247f895021f6772b52e0d57b0f6ac3bef66dfd58964/_data\", \"Destination\": \"volume01\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" } ], \"Config\": { \"Hostname\": \"1e52e32ab8e7\", \"Domainname\": \"\", \"User\": \"\", \"AttachStdin\": true, \"AttachStdout\": true, \"AttachStderr\": true, \"Tty\": true, \"OpenStdin\": true, \"StdinOnce\": true, \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ], \"Cmd\": [ \"/bin/bash\" ], \"Image\": \"5c7e025fc4ff\", \"Volumes\": { \"volume01\": {}, \"volume02\": {} }, \"WorkingDir\": \"\", \"Entrypoint\": null, \"OnBuild\": null, \"Labels\": { \"org.label-schema.build-date\": \"20200611\", \"org.label-schema.license\": \"GPLv2\", \"org.label-schema.name\": \"CentOS Base Image\", \"org.label-schema.schema-version\": \"1.0\", \"org.label-schema.vendor\": \"CentOS\" } }, \"NetworkSettings\": { \"Bridge\": \"\", \"SandboxID\": \"20dbaff762c3e3f81ec4497c34edcf3ff34842bddabb3d0705d1c90551729f4d\", \"HairpinMode\": false, \"LinkLocalIPv6Address\": \"\", \"LinkLocalIPv6PrefixLen\": 0, \"Ports\": {}, \"SandboxKey\": \"/var/run/docker/netns/20dbaff762c3\", \"SecondaryIPAddresses\": null, \"SecondaryIPv6Addresses\": null, \"EndpointID\": \"ce3538bdbc3b50aad38552ea578a45fd4f1db6cbc2e567012efc8b2421433691\", \"Gateway\": \"172.17.0.1\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"IPAddress\": \"172.17.0.4\", \"IPPrefixLen\": 16, \"IPv6Gateway\": \"\", \"MacAddress\": \"02:42:ac:11:00:04\", \"Networks\": { \"bridge\": { \"IPAMConfig\": null, \"Links\": null, \"Aliases\": null, \"NetworkID\": \"68c30b64280cd79fbbee1895f55c67d9febdb11a032fcbd4326319b1ea5c5075\", \"EndpointID\": \"ce3538bdbc3b50aad38552ea578a45fd4f1db6cbc2e567012efc8b2421433691\", \"Gateway\": \"172.17.0.1\", \"IPAddress\": \"172.17.0.4\", \"IPPrefixLen\": 16, \"IPv6Gateway\": \"\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"MacAddress\": \"02:42:ac:11:00:04\", \"DriverOpts\": null } } } } ] # 外部挂载信息 \"Mounts\": [ { \"Type\": \"volume\", \"Name\": \"e113c26dfe915b20080e5a9f7ae700713d4f443ca95b9e80d82d351ace6b88ca\", \"Source\": \"/var/lib/docker/volumes/e113c26dfe915b20080e5a9f7ae700713d4f443ca95b9e80d82d351ace6b88ca/_data\", \"Destination\": \"volume02\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" }, { \"Type\": \"volume\", \"Name\": \"b78af0b69e7fdfa0c87d2247f895021f6772b52e0d57b0f6ac3bef66dfd58964\", \"Source\": \"/var/lib/docker/volumes/b78af0b69e7fdfa0c87d2247f895021f6772b52e0d57b0f6ac3bef66dfd58964/_data\", \"Destination\": \"volume01\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" } ], 测试一下刚才的文件是否同步出去了 [root@iz8g9301trfnpxz home]# cd /var/lib/docker/volumes/e113c26dfe915b20080e5a9f7ae700713d4f443ca95b9e80d82d351ace6b88ca/_data [root@iz8g9301trfnpxz _data]# ls [root@iz8g9301trfnpxz _data]# cd /var/lib/docker/volumes/b78af0b69e7fdfa0c87d2247f895021f6772b52e0d57b0f6ac3bef66dfd58964/_data [root@iz8g9301trfnpxz _data]# ls container.txt [root@iz8g9301trfnpxz _data]# 这种方式我们未来使用的十分多,因为我们通常会构建自己的镜像 假设构建镜像的时候没有挂载卷,要手动镜像挂载 -v 卷名:容器内路径! 容器间也可以数据共享 数据卷容器 比如我们两个mysql同步数据new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:56:23 "},"base/2020-07-26-docker_数据卷容器.html":{"url":"base/2020-07-26-docker_数据卷容器.html","title":"数据卷容器","keywords":"","body":"数据卷容器数据卷容器 比如我们两个mysql同步数据 # 启动3个容器,通过我们刚才自己写的镜像启动 测试: 可以删除我们的docker01,然后查看一下docker02和docker03是否还可以访问这个文件 测试的结果依旧可以访问 这是一种备份的机制,而不是共享的数据 结论: 容器之间可以做一些配置的传递,数据卷容器的生命周期一直持续到没有人使用为止 但是一旦你持久化到了本地,这个时候,本地的数据不会删除 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-23 20:00:30 "},"base/26_docker_dockerFile.html":{"url":"base/26_docker_dockerFile.html","title":"dockerFile","keywords":"","body":"DockerFiledocker file 介绍docker file 构建过程表示注释DockerFile dockerfile是用来构建docker镜像的文件! 命令参数脚本 构建步骤: 编写一个dockerfile 文件 docker build 构建成为一个镜像 docker run 运行镜像 docker push 发布镜像(dockerHub,阿里云镜像仓库!) 查看一下官网上面再怎么做的 很多官方镜像都是基础包,很多功能都没有 ping clear 这种命令需要自己安装 centos里面不是基础包,我们需要自己来搭建自己的镜像 官方既然可以制作镜像,那我们也可以 docker file 介绍 docker file 构建过程 很多指令: 基础知识: 每个保留关键字都是必须是大写字母 执行从上到下顺序执行 表示注释 每个指令都会创建提交一个新的镜像层,并提交! dockerfile是面向开发的,我们以后要发布项目,做镜像,就需要编写dockerfile文件,这个文件十分简单! docker镜像逐渐成为企业交付标准,必须要掌握 Dockerfile: 构建文件,定义了一切步骤,源代码 DockerImages:通过dockerfile 构建生成的镜像,最终发布和运行的产品,原来是jar war docker容器: 容器就是镜像运行起来提供服务器. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-06 19:11:16 "},"base/27_docker_dockerFile指令说明.html":{"url":"base/27_docker_dockerFile指令说明.html","title":"dockerFile指令说明","keywords":"","body":"DockerFile指令说明DockerFile指令说明 FROM # 基础镜像,一切从这里开始构建 MAINTAINER # 镜像是谁写的,姓名+邮箱 RUN # 镜像构建的时候需要运行的命令 ADD # 步骤:tomcat镜像,这个tomcat压缩包!添加内容 WORKDIR # 镜像的工作目录 VOLUME # 挂载的目录 EXPOST # 暴露的端口配置 CMD # 指定这个容器启动的时候要运行的命令,只有最后一个会生效 ENTRYPOINT # 指定这个容器启动的时候要运行的命令,可以追加命令 ONBUILD # 当构建一个被继承 DockerFile这个时候就会运行ONBUILD 的指令,触发指令 COPY # 类似ADD,将我们的文件拷贝到镜像中 ENV # 构建的时候设置环境变量! new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-23 19:52:14 "},"base/28_docker_构建自己的centos.html":{"url":"base/28_docker_构建自己的centos.html","title":"构建自己的centos","keywords":"","body":"实战测试命令 docker build -f dockerfile 文件路径 -t 镜像名实战测试 实战测试 创建自己的centos # 编写dockerfile配置文件 [root@iz8g9301trfnpxz ~]# cd /home [root@iz8g9301trfnpxz home]# mkdir dockerfile [root@iz8g9301trfnpxz home]# ls admin ceshi dockerfile docker-test-volume kuangshen.java mysql test.java [root@iz8g9301trfnpxz home]# cd dockerfile/ [root@iz8g9301trfnpxz dockerfile]# ls [root@iz8g9301trfnpxz dockerfile]# vim mydocker-centos [root@iz8g9301trfnpxz dockerfile]# cat mydocker-centos FROM centos MAINTAINER victor ENV MYPATH /urs/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"-------------------end------------------\" CMD /bin/bash # 通过这个文件构建镜像 通过build命令进行构建 命令 docker build -f dockerfile 文件路径 -t 镜像名 [root@iz8g9301trfnpxz dockerfile]# docker build -f mydocker-centos -t mycentos:0.1 . Sending build context to Docker daemon 2.048kB Step 1/10 : FROM centos ---> 831691599b88 Step 2/10 : MAINTAINER victor ---> Running in 5485ccbf2672 Removing intermediate container 5485ccbf2672 ---> 131330e2008d Step 3/10 : ENV MYPATH /urs/local ---> Running in 7ddbc3982cdc Removing intermediate container 7ddbc3982cdc ---> d8afdf73ae5e Step 4/10 : WORKDIR $MYPATH ---> Running in ee1bb41513bc Removing intermediate container ee1bb41513bc ---> 77b75be518d6 Step 5/10 : RUN yum -y install vim ---> Running in 4d801fad886d CentOS-8 - AppStream 409 kB/s | 5.8 MB 00:14 CentOS-8 - Base 2.5 MB/s | 2.2 MB 00:00 CentOS-8 - Extras 941 B/s | 7.0 kB 00:07 Dependencies resolved. ================================================================================ Package Arch Version Repository Size ================================================================================ Installing: vim-enhanced x86_64 2:8.0.1763-13.el8 AppStream 1.4 M Installing dependencies: gpm-libs x86_64 1.20.7-15.el8 AppStream 39 k vim-common x86_64 2:8.0.1763-13.el8 AppStream 6.3 M vim-filesystem noarch 2:8.0.1763-13.el8 AppStream 48 k which x86_64 2.21-12.el8 BaseOS 49 k Transaction Summary ================================================================================ Install 5 Packages Total download size: 7.8 M Installed size: 31 M Downloading Packages: (1/5): gpm-libs-1.20.7-15.el8.x86_64.rpm 219 kB/s | 39 kB 00:00 (2/5): vim-filesystem-8.0.1763-13.el8.noarch.rp 434 kB/s | 48 kB 00:00 (3/5): which-2.21-12.el8.x86_64.rpm 2.5 MB/s | 49 kB 00:00 (4/5): vim-enhanced-8.0.1763-13.el8.x86_64.rpm 813 kB/s | 1.4 MB 00:01 (5/5): vim-common-8.0.1763-13.el8.x86_64.rpm 839 kB/s | 6.3 MB 00:07 -------------------------------------------------------------------------------- Total 805 kB/s | 7.8 MB 00:09 warning: /var/cache/dnf/AppStream-02e86d1c976ab532/packages/gpm-libs-1.20.7-15.el8.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 8483c65d: NOKEY CentOS-8 - AppStream 862 kB/s | 1.6 kB 00:00 Importing GPG key 0x8483C65D: Userid : \"CentOS (CentOS Official Signing Key) \" Fingerprint: 99DB 70FA E1D7 CE22 7FB6 4882 05B5 55B3 8483 C65D From : /etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial Key imported successfully Running transaction check Transaction check succeeded. Running transaction test Transaction test succeeded. Running transaction Preparing : 1/1 Installing : which-2.21-12.el8.x86_64 1/5 Installing : vim-filesystem-2:8.0.1763-13.el8.noarch 2/5 Installing : vim-common-2:8.0.1763-13.el8.x86_64 3/5 Installing : gpm-libs-1.20.7-15.el8.x86_64 4/5 Running scriptlet: gpm-libs-1.20.7-15.el8.x86_64 4/5 Installing : vim-enhanced-2:8.0.1763-13.el8.x86_64 5/5 Running scriptlet: vim-enhanced-2:8.0.1763-13.el8.x86_64 5/5 Running scriptlet: vim-common-2:8.0.1763-13.el8.x86_64 5/5 Verifying : gpm-libs-1.20.7-15.el8.x86_64 1/5 Verifying : vim-common-2:8.0.1763-13.el8.x86_64 2/5 Verifying : vim-enhanced-2:8.0.1763-13.el8.x86_64 3/5 Verifying : vim-filesystem-2:8.0.1763-13.el8.noarch 4/5 Verifying : which-2.21-12.el8.x86_64 5/5 Installed: gpm-libs-1.20.7-15.el8.x86_64 vim-common-2:8.0.1763-13.el8.x86_64 vim-enhanced-2:8.0.1763-13.el8.x86_64 vim-filesystem-2:8.0.1763-13.el8.noarch which-2.21-12.el8.x86_64 Complete! Removing intermediate container 4d801fad886d ---> 9458be1e73c5 Step 6/10 : RUN yum -y install net-tools ---> Running in c764b7488e52 Last metadata expiration check: 0:00:17 ago on Fri Jul 31 06:20:50 2020. Dependencies resolved. ================================================================================ Package Architecture Version Repository Size ================================================================================ Installing: net-tools x86_64 2.0-0.51.20160912git.el8 BaseOS 323 k Transaction Summary ================================================================================ Install 1 Package Total download size: 323 k Installed size: 1.0 M Downloading Packages: net-tools-2.0-0.51.20160912git.el8.x86_64.rpm 3.4 MB/s | 323 kB 00:00 -------------------------------------------------------------------------------- Total 208 kB/s | 323 kB 00:01 Running transaction check Transaction check succeeded. Running transaction test Transaction test succeeded. Running transaction Preparing : 1/1 Installing : net-tools-2.0-0.51.20160912git.el8.x86_64 1/1 Running scriptlet: net-tools-2.0-0.51.20160912git.el8.x86_64 1/1 Verifying : net-tools-2.0-0.51.20160912git.el8.x86_64 1/1 Installed: net-tools-2.0-0.51.20160912git.el8.x86_64 Complete! Removing intermediate container c764b7488e52 ---> 7e388732db7d Step 7/10 : EXPOSE 80 ---> Running in 3805ab7a1061 Removing intermediate container 3805ab7a1061 ---> de64af90d6a6 Step 8/10 : CMD echo $MYPATH ---> Running in 30d1c0c9ba45 Removing intermediate container 30d1c0c9ba45 ---> 0dcdb63da784 Step 9/10 : CMD echo \"-------------------end------------------\" ---> Running in 5ea7cbe4f0c7 Removing intermediate container 5ea7cbe4f0c7 ---> 146bc756b80a Step 10/10 : CMD /bin/bash ---> Running in 537d8346e6be Removing intermediate container 537d8346e6be ---> 3f4f73543aa2 Successfully built 3f4f73543aa2 Successfully tagged mycentos:0.1 [root@iz8g9301trfnpxz dockerfile]# 现在我们使用就可以用了 [root@iz8g9301trfnpxz dockerfile]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE mycentos 0.1 3f4f73543aa2 About a minute ago 287MB kuangshen/centos 1.0 5c7e025fc4ff 4 hours ago 215MB tomcat02 1.0 b17b415625d5 6 hours ago 657MB tomcat latest 9a9ad4f631f8 2 days ago 647MB portainer/portainer latest 62771b0b9b09 8 days ago 79.1MB mysql 5.7 8679ced16d20 8 days ago 448MB nginx latest 8cf1bfb43ff5 9 days ago 132MB redis latest 50541622f4f1 9 days ago 104MB centos latest 831691599b88 6 weeks ago 215MB elasticsearch 7.6.2 f29a1ee41030 4 months ago 791MB elasticsearch latest 5acf0e8da90b 22 months ago 486MB [root@iz8g9301trfnpxz dockerfile]# docker run -it mycentos:0.1 [root@88886ca9deb0 local]# pwd /urs/local [root@88886ca9deb0 local]# 对比之前原生的,centos 我们增加的镜像 我们可以列出咱们的本地镜像的变更历史 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-23 19:52:14 "},"base/29_docker_CMD和ENTRYPOINT区别.html":{"url":"base/29_docker_CMD和ENTRYPOINT区别.html","title":"CMD和ENTRYPOINT区别","keywords":"","body":"CMD和ENTRYPOINT区别CMD和ENTRYPOINT区别 https://www.bilibili.com/video/BV1og4y1q7M4?p=29 测试cmd命令 [root@iz8g9301trfnpxz dockerfile]# cat dockerfile-cmd-test FROM centos CMD [\"ls\",\"-a\"] 构建镜像,执行 ```bash [root@iz8g9301trfnpxz /]# ls bin boot dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@iz8g9301trfnpxz /]# cd /home/dockerfile/ [root@iz8g9301trfnpxz dockerfile]# ls mydocker-centos [root@iz8g9301trfnpxz dockerfile]# vim dockerfile-cmd-test [root@iz8g9301trfnpxz dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest . Sending build context to Docker daemon 3.072kB Step 1/2 : FROM centos ---> 831691599b88 Step 2/2 : CMD [\"ls\",\"-a\"] ---> Running in e6dca2412833 Removing intermediate container e6dca2412833 ---> cef9ed46536a Successfully built cef9ed46536a Successfully tagged cmdtest:latest [root@iz8g9301trfnpxz dockerfile]# ``` new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-23 19:52:14 "},"base/30_docker_dockerfile制作Tomcat镜像.html":{"url":"base/30_docker_dockerfile制作Tomcat镜像.html","title":"dockerfile制作Tomcat镜像","keywords":"","body":"CMD和ENTRYPOINT区别CMD和ENTRYPOINT区别 https://www.bilibili.com/video/BV1og4y1q7M4?p=30 测试cmd命令 [root@iz8g9301trfnpxz dockerfile]# cat dockerfile-cmd-test FROM centos CMD [\"ls\",\"-a\"] 构建镜像,执行 [root@iz8g9301trfnpxz /]# ls bin boot dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@iz8g9301trfnpxz /]# cd /home/dockerfile/ [root@iz8g9301trfnpxz dockerfile]# ls mydocker-centos [root@iz8g9301trfnpxz dockerfile]# vim dockerfile-cmd-test [root@iz8g9301trfnpxz dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest . Sending build context to Docker daemon 3.072kB Step 1/2 : FROM centos ---> 831691599b88 Step 2/2 : CMD [\"ls\",\"-a\"] ---> Running in e6dca2412833 Removing intermediate container e6dca2412833 ---> cef9ed46536a Successfully built cef9ed46536a Successfully tagged cmdtest:latest [root@iz8g9301trfnpxz dockerfile]# 项目部署成功,可以直接访问ok! 我们以后开发步骤:需要掌握Dockerfile 我们以后都是使用docker镜像来发布的 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-23 19:52:14 "},"base/31_docker_发布镜像.html":{"url":"base/31_docker_发布镜像.html","title":"发布镜像","keywords":"","body":"发布自己的镜像发布自己的镜像 https://www.bilibili.com/video/BV1og4y1q7M4?p=31 DockerHub 地址 https://hub.docker.com/ 注册自己的账号 确定这个账号可以登录 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-06 19:11:16 "},"base/32_docker_发布阿里云镜像.html":{"url":"base/32_docker_发布阿里云镜像.html","title":"发布阿里云镜像","keywords":"","body":"发布自己的镜像发布自己的镜像 阿里云进项 登录阿里云 找到容器镜像服务 创建命名空间 创建容器镜像 浏览阿里云 登录 拉取 将镜像推送到registry 阿里云容器镜像地址就参考官方地址! 将我们的网站开源 https://www.bilibili.com/video/BV1og4y1q7M4?p=33 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-06 19:11:16 "},"base/33_docker_所有流程小结.html":{"url":"base/33_docker_所有流程小结.html","title":"所有流程小结","keywords":"","body":"现在docker 已经差不多了 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-06 19:11:16 "},"base/34_docker_网络详情.html":{"url":"base/34_docker_网络详情.html","title":"网络详情","keywords":"","body":"docker0网络理解docker0docker0网络 理解docker0 清空所有环境 # 测试 [root@iz8g9301trfnpxz home]# docker rmi -f $(docker images -aq) Untagged: mycentos:0.1 # 获取当前ip地址 [root@iz8g9301trfnpxz home]# ip addr 1: lo: mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: eth0: mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:16:3e:14:13:0a brd ff:ff:ff:ff:ff:ff inet 172.24.40.74/18 brd 172.24.63.255 scope global dynamic eth0 valid_lft 315035939sec preferred_lft 315035939sec 3: docker0: mtu 1500 qdisc noqueue state DOWN link/ether 02:42:4a:5e:af:07 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever 三个网络 # 问题:docker 是如何处理容器网络访问的? # 测试 [root@iz8g9301trfnpxz home]# docker run -d -P --name tomcat03 tomcat # 查看容器内地址 [root@iz8g9301trfnpxz home]# docker run -d -P --name tomcat03 tomcat fc3283ac304d54cfa0f04b5f1904a36e8bc452b99882af575c255206a7308072 [root@iz8g9301trfnpxz home]# docker exec -it tomcat03 ip addr 1: lo: mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 72: eth0@if73: mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 思考 linux 能不能 ping 通这个容器内部地址 [root@iz8g9301trfnpxz home]# ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data. 64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.063 ms 64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.049 ms 64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.050 ms # linux 能够访问容器内部 原理 我们没启动一个docker 容器,docker 就会给docker容器分配一个ip,我们只要安装了docker,就会有一个网卡docker0桥接模式,使用的技术是evth-pair技术! 再次测试ip addr 在一个容器中测试,发现由多了一个网卡 我们发现这个容器带来的网卡,都是一对一对儿的 evth-pair 就是一对的虚拟设备接口,他们都是成对出现的,一段连着协议,一段彼此相连 正因为有这个特性,evth-pair 充当一个桥梁,连接各种虚拟网络设备的 OpenStac,Docker容器之间的连接,OVS的连接,都是使用evth-pair技术 我们来测试下tomcat01和tomcat02是否可以ping通!docker exec -it tomcat02 ping 172.18.0.2 # 结论:容器和容器之间是可以互相ping通的 绘制一个网络模型图: new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-23 19:52:14 "},"base/35_docker_容器互联.html":{"url":"base/35_docker_容器互联.html","title":"容器互联","keywords":"","body":"docker0容器互联docker0容器互联 原理 我们没启动一个docker 容器,docker 就会给docker容器分配一个ip,我们只要安装了docker,就会有一个网卡docker0桥接模式,使用的技术是evth-pair技术! 再次测试ip addr 在一个容器中测试,发现由多了一个网卡 我们发现这个容器带来的网卡,都是一对一对儿的 evth-pair 就是一对的虚拟设备接口,他们都是成对出现的,一段连着协议,一段彼此相连 正因为有这个特性,evth-pair 充当一个桥梁,连接各种虚拟网络设备的 OpenStac,Docker容器之间的连接,OVS的连接,都是使用evth-pair技术 我们来测试下tomcat01和tomcat02是否可以ping通!docker exec -it tomcat02 ping 172.18.0.2 # 结论:容器和容器之间是可以互相ping通的 绘制一个网络模型图: new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-23 19:52:14 "},"base/36_docker_自定义网络.html":{"url":"base/36_docker_自定义网络.html","title":"自定义网络","keywords":"","body":"docker0自定义网络docker0自定义网络 查看所有的网络 [root@iz8g9301trfnpxz home]# docker network ls NETWORK ID NAME DRIVER SCOPE 68c30b64280c bridge bridge local e5373821382b host host local bc64d000f692 none null local 网络模式 网络模式 解释 bridge 桥接docker(默认,自己创建也是bridge模式) none 不配置网络 host 和宿主机共享网络 container 容器网络连通!(用的少!局限很大) 测试 # 我们直接启动的命令 --net bridge ,而这个就是我们的docker0 [root@iz8g9301trfnpxz home]# docker run -d -P --name tomcat01 tomcat [root@iz8g9301trfnpxz home]# docker run -d -P --name tomcat01 --net bridge tomcat 120ae6154cb8a090d7bf43c5b25620fa6913afd1eae5426ec6dc3fb95de1e4b2 # docker0 特点: 默认,域名不能访问,--link可以打通连接! # 我们可以自定义一个网络! # --driver bridge # --subnet 192.168.0.0/16 192.168.0.2 # --gateway 192.168.0.1 [root@iz8g9301trfnpxz home]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet 8a651bded67f27601cc17590df67043bad863e8b9e3b8b3f9b636bf8ebbb30f8 [root@iz8g9301trfnpxz home]# docker network ls NETWORK ID NAME DRIVER SCOPE 68c30b64280c bridge bridge local e5373821382b host host local 8a651bded67f mynet bridge local bc64d000f692 none null local 查看一下 ```bash [root@iz8g9301trfnpxz home]# docker network inspect mynet [ { \"Name\": \"mynet\", \"Id\": \"8a651bded67f27601cc17590df67043bad863e8b9e3b8b3f9b636bf8ebbb30f8\", \"Created\": \"2020-08-03T09:57:58.644192346+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": {}, \"Options\": {}, \"Labels\": {} } ] [root@iz8g9301trfnpxz home]# ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-23 19:52:14 "},"base/37_docker_网络连通.html":{"url":"base/37_docker_网络连通.html","title":"网络连通","keywords":"","body":"结论: 假设要跨网络操作别人,就需要使用docker network connect 连通!.... new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-06 19:11:16 "},"base/38_docker_Redis集群实战.html":{"url":"base/38_docker_Redis集群实战.html","title":"Redis集群实战","keywords":"","body":"Redis集群Redis集群 分片+ 高可用 + 负载均衡 需要翻看其那面的redis基础全集 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-06 19:11:16 "},"base/39_docker_SpringBoot微服务打包docker镜像.html":{"url":"base/39_docker_SpringBoot微服务打包docker镜像.html","title":"SpringBoot微服务打包docker镜像","keywords":"","body":"SpringBoot 微服务打包Docker镜像SpringBoot 微服务打包Docker镜像 构建springboot项目 打包应用 编写dockerfile 构建镜像 发布运行! 以后我们使用了docker之后,给别人交付的就是上传的打包好的镜像 到了这里我们已经完全够用了docker 预告:若有很多镜像,???100个镜像 docker compose docker Swarm CI/CD 之 Jenkinsnew Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-06 19:11:16 "},"base/40_docker_小结.html":{"url":"base/40_docker_小结.html","title":"小结","keywords":"","body":"小结小结 docker 常用命令 **重要 镜像原理 数据卷的挂载new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-06 19:11:16 "},"advance/01_docker_基础回顾.html":{"url":"advance/01_docker_基础回顾.html","title":"基础回顾","keywords":"","body":"Docker安装Docker 安装环境准备环境查看安装3.设置镜像的仓库4. 现在就可以安装最新的docker的引擎5. 如果想要安装不是最新版本的,也可以指定安装的版本Docker安装 Docker 安装 环境准备 需要会一点点儿的Linux基础 Centos7 我们使用Xshell连接远程服务器进行操作 环境查看 centos版本 3.10.0-514.26.2.el7.x86_64 ## 系统版本 NAME=\"CentOS Linux\" VERSION=\"7 (Core)\" ID=\"centos\" ID_LIKE=\"rhel fedora\" VERSION_ID=\"7\" PRETTY_NAME=\"CentOS Linux 7 (Core)\" ANSI_COLOR=\"0;31\" CPE_NAME=\"cpe:/o:centos:centos:7\" HOME_URL=\"https://www.centos.org/\" BUG_REPORT_URL=\"https://bugs.centos.org/\" CENTOS_MANTISBT_PROJECT=\"CentOS-7\" CENTOS_MANTISBT_PROJECT_VERSION=\"7\" REDHAT_SUPPORT_PRODUCT=\"centos\" REDHAT_SUPPORT_PRODUCT_VERSION=\"7\" 安装 帮助文档 # 1. 卸载旧的版本 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2.# 需要的安装包 sudo yum install -y yum-utils 3.设置镜像的仓库 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 默认是从国外下载的,我们是使用国内的 docker阿里云国内镜像地址 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 推荐使用阿里云的 在安装之前建议更新yum更新索引 sudo yum makecache fast 4. 现在就可以安装最新的docker的引擎 sudo yum install docker-ce docker-ce-cli containerd.io docker-ce 是社区版本的 docker-ee 是企业版本的 5. 如果想要安装不是最新版本的,也可以指定安装的版本 sudo yum install docker-ce- docker-ce-cli- containerd.io 安装完成之后就可以启动docker,最后helloworld sudo systemctl start docker 使用docker version 看看安装成功没 [root@iz8g9301trfnpxz /]# docker version Client: Docker Engine - Community Version: 19.03.12 API version: 1.40 Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:46:54 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.12 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:45:28 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.13 GitCommit: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc: Version: 1.0.0-rc10 GitCommit: dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init: Version: 0.18.0 GitCommit: fec3683 docker helloworld [root@iz8g9301trfnpxz /]# docker run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ 查看一下下载的helloworld的镜像 在不在 [root@iz8g9301trfnpxz /]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 6 months ago 13.3kB [root@iz8g9301trfnpxz /]# docker Compose docker Swarm docker Stack docker Secret docker Config 容器单独它是没有意义的 有意义的是容器编排 k8snew Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:46:35 "},"advance/02_docker_DockerCompose介绍.html":{"url":"advance/02_docker_DockerCompose介绍.html","title":"DockerCompose介绍","keywords":"","body":"Docker Compose简介docker SwarmDocker Compose 简介 docker dockerfile build run 手动操作，单个容器 微服务。100个微服务！ 依赖关系 Docker Compose 来轻松高效的管理容器。定义运行多个容器 k8s描述文件 官方介绍 定义，运行，多个容器。 所有的环境都可以使用我们的docker compose 三个步骤： DockerFile保证我们的项目在任何地方可以运行 services什么是服务 docker-compose。yml这个文件怎么写 启动项目 作用： 批量容器编排。 我自己理解 Compose 是Docker官方的开源项目。需要安装！这个可不是在docker里面的 dockerfile让程序在任何地方运行.web服务.redis,mysql,nginx,...多个容器. 这么多环境要是一个一个启动,太麻烦了,所以Compose应运而生 docker-compose up 100个服务. Compose:重要的概念 服务services,容器.应用.(web应用,redis,mysql,...) 项目project.一组关联的容器.博客.web,mysql、 wp 未来我们的搭建肯定是要用Compose的,不可能用docker跑起来 docker Swarm 集群方式的部署,4台阿里云服务器,2 4g new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-22 19:58:08 "},"advance/03_docker_Compose安装.html":{"url":"advance/03_docker_Compose安装.html","title":"Compose安装","keywords":"","body":"Compose安装Compose安装 1.下载 上面那个可能会很慢 用这个要快一点儿 curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose 试一下 [root@iz8g9301trfnpxz ~]# curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s` - `uname -m` > /usr/local/bin/docker-compose curl: option -: is unknown curl: try 'curl --help' or 'curl --manual' for more information [root@iz8g9301trfnpxz ~]# curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 423 100 423 0 0 502 0 --:--:-- --:--:-- --:--:-- 501 100 16.7M 100 16.7M 0 0 8412k 0 0:00:02 0:00:02 --:--:-- 24.3M [root@iz8g9301trfnpxz ~]# cd /usr/local/bin/ [root@iz8g9301trfnpxz bin]# ls docker-compose jemalloc-config jemalloc.sh jeprof libmcrypt-config luajit luajit-2.0.4 mcrypt mdecrypt [root@iz8g9301trfnpxz bin]# 安装成功 [root@iz8g9301trfnpxz bin]# sudo chmod +x docker-compose [root@iz8g9301trfnpxz bin]# docker-compose Define and run multi-container applications with Docker. [root@iz8g9301trfnpxz bin]# docker-compose -version docker-compose version 1.25.5, build 8a1c60f6 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:46:35 "},"advance/04_docker_Compose初体验.html":{"url":"advance/04_docker_Compose初体验.html","title":"Compose初体验","keywords":"","body":"Compose初体验Get started with Docker ComposeStep 3: Define services in a Compose fileStep 4: Build and run your app with Compose总结流程docker小结Compose初体验 体验 地址: https://docs.docker.com/compose/gettingstarted/ 看一看官方怎么说 Get started with Docker Compose Estimated reading time: 10 minutes On this page you build a simple Python web application running on Docker Compose. The application uses the Flask framework and maintains a hit counter in Redis. While the sample uses Python, the concepts demonstrated here should be understandable even if you’re not familiar with it. 这里面用到了python中的flask框架 python应用,计数器 一顿操作开始 创建文件夹 [root@iz8g9301trfnpxz home]# mkdir composetest [root@iz8g9301trfnpxz home]# cd composetest/ [root@iz8g9301trfnpxz composetest]# ll total 0 [root@iz8g9301trfnpxz composetest]# vim app.py [root@iz8g9301trfnpxz composetest]# vim requirements.txt [root@iz8g9301trfnpxz composetest]# vim Dockerfile 创建app.py文件内容 import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count) 创建requirements.txt内容 flask redis 创建dockerfile FROM python:3.7-alpine WORKDIR /code ENV FLASK_APP app.py ENV FLASK_RUN_HOST 0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers COPY requirements.txt requirements.txt RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple EXPOSE 5000 COPY . . CMD [\"flask\", \"run\"] 定义服务 Step 3: Define services in a Compose file Create a file called docker-compose.yml in your project directory and paste the following: version: '3' services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" 执行 Step 4: Build and run your app with Compose From your project directory, start up your application by running docker-compose up. 总结 应用 app.py Dockerfile应用打包为镜像 Docker-compose yaml文件(定义整个服务,需要的环境.web, redis) 完整的上线服务! 启动compose项目(docker-compose up) 流程 创建网络 执行Docker-compose.yml文件 启动服务 docker-compose yaml Creating composetest_web_1 ... done Creating composetest_redis_1 ... done 文件名 composetest 服务 version: '3' services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" compose up 后,会自动帮我们安装docker需要的镜像 比如python mysql:3306 10个容器实例:mysql 10, ip(项目中的内容都在同一个网络下面.域名访问) 如果在同一个网络下,我们可以直接通过域名访问. 可以一键启动,服务,都是可以的 docker小结 Docker镜像.run-> 容器 DockerFile构建镜像 (服务打包) docker-compose启动项目(编排,多个微服务/环境) docker网络 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:46:35 "},"advance/05_docker_Compose配置编写规则.html":{"url":"advance/05_docker_Compose配置编写规则.html","title":"Compose配置编写规则","keywords":"","body":"yaml规则 docker-compose.yaml核心 https://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples # 3层 version: \" # 版本 services: # 服务 服务1:web # 服务配置 images build network ...... 服务2:redis ... 服务3:redis ... # 其他配置 volumes: networks: configs: new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-22 19:58:08 "},"advance/06_docker_使用Compose一键部署WP博客.html":{"url":"advance/06_docker_使用Compose一键部署WP博客.html","title":"使用Compose一键部署WP博客","keywords":"","body":"开源项目开源项目 博客 下载程序,安装数据库,配置... compose应用.->一键启动 下载项目(docker-compose.yml) 如果需要文件dockerfile 文件准备齐全,直接一键启动项目! wordpress 一键搭建自己的博客 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-22 19:58:08 "},"advance/07_docker_实战_编写自己的微服务上线.html":{"url":"advance/07_docker_实战_编写自己的微服务上线.html","title":"实战_编写自己的微服务上线","keywords":"","body":"微服务上线微服务上线 实战 编写项目微服务 dockerfile构建镜像 docker-compose.yaml编排项目 丢到服务器 docker-compose up 小结: 未来项目只要有docker-compose文件.按照这个规则,启动编排容器 公司: docker-compose.直接启动 网上开源项目:docker-compose一键搞定 假设项目要重新部署打包 docker-compose up --build # 重新构建 总结: 工程,服务,容器, 项目compose:三层 工程Project 服务 服务 容器 运行实例 ! docker k8s 容器 pods kuber controler apply -f\"xxxx.yaml\" docker compose 搞定 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-22 19:58:08 "},"advance/08_docker_环境准备_阿里云购买4台服务器.html":{"url":"advance/08_docker_环境准备_阿里云购买4台服务器.html","title":"环境准备_阿里云购买4台服务器","keywords":"","body":"阿里云买服务器Docker Swarm阿里云买服务器 Docker Swarm 购买服务器 基础配置 配置安全组 一定要在一个安全组里面,不在一个安全组里面,你内网是ping不通的 内网是不需要流量的,要是走外网那就....嗯!~~ 带宽可以多一点儿,反正是按照量收费的 现在就好了,创建成功 要是买这个在aliyun里面的余额要大于100的 你没钱你玩啥服务器 4台机器安装docker 有的人一个一个来安装,现在我来一波操作 你这样输入那就nb了 现在我们安装我们的gcc环境 这些高级实战对于学生来说有压力 尤其是那些白嫖的,看到这里都不想看了,还要花钱,头都大了 你们在本地搭建的那些都叫玩具 根本玩不起来 这个卸载不需要,可以忽略, 然后 和我们单机安装一样 技巧: xshell直接同步操作,省时间,因为我们这个都是花钱玩儿的,不可能.... new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-22 19:58:08 "},"advance/09_docker_Swarm集群搭建.html":{"url":"advance/09_docker_Swarm集群搭建.html","title":"Swarm集群搭建","keywords":"","body":"Swarm搭建集群Swarm 工作模式 Docker Engine1.12 introduce Swarm mode that enables you to create a cluster of one or more Docker If you haven't already ,read through the swarm mode overview and key concepts. 搭建集群 私网,公网 初始化节点docker swarm init docker swarm join 加入一个节点! # 获取令牌 docker swarm join-token manager docker swarm join-token worker 把后面的节点搭建进去 100台服务器 生成主节点 加入(管理者,worker) 目标:双主双从!new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-22 19:58:08 "},"advance/10_docker_Raft一致协议了解.html":{"url":"advance/10_docker_Raft一致协议了解.html","title":"Raft一致协议了解","keywords":"","body":"Raft协议Raft协议 双主双从:假设一个节点挂了! 其他节点是否可以用! Raft协议: 保证大多数节点存活才可以用. 只要>1,集群至少大于3台! 实验: 将docker1 机器停止.宕机! 双主.另外一个主节点也不能使用了! 可以将咱们其他节点离开试试 work就是工作的,管理节点操作! 3台机器设置为了管理节点. 十分简单: 集群,可用! 3个主节点. > 1台管理节点存活! Raft协议: 保证大多数节点存活,才可用,这就是高可用 体会 弹性,负载,扩缩容new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-22 19:58:08 "},"advance/11_docker_Swarm集群弹性创建服务.html":{"url":"advance/11_docker_Swarm集群弹性创建服务.html","title":"Swarm集群弹性创建服务","keywords":"","body":"体会 弹性,负载,扩缩容 以后告别 docker run! 如果你还是用docker run 那你docker 还是玩具状态 dokcer-compose up! 启动一个项目.单机! 集群: swarm docker service 容器 => 服务! redis! = 3份! 容器! 集群: 高可用, web-> redis(3台,不同的机器上!) 容器 => 服务 => 副本! redis服务 => 10个副本 ! (同时开启10个redis容器) 体验: 创建服务,动态扩展服务,动态 灰度发布:金丝雀发布! 停止 淘宝! 不可能有404 就是说升级不影响发布 docker run # 容器启动 ! 不具有扩缩容器 docker service # 服务! 具有扩缩容器,滚动更新! 查看服务 动态扩缩容 服务,集群中任意的节点都可以访问.服务可以有多个副本动态扩缩容实现高可用! 弹性,扩缩容 十分重要 10台服务器 比如 aliyun 10000台服务器 , 卖给别人 ! 虚拟化! 服务的高可用,任何的企业 delete the password https://www.bilibili.com/video/BV1kv411q7Qc?p=11 移除! docker swarm 其实并不难 只要会搭建集群,会启动服务,动态管理容器就可以了! new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:46:35 "},"advance/12_docker_Swarm概念拓展学习.html":{"url":"advance/12_docker_Swarm概念拓展学习.html","title":"Swarm概念拓展学习","keywords":"","body":"概念总结概念总结 swarm 集群的管理编号.docker可以初始化一个swarm集群,其他节点可以加入.(管理,工作者) Node 就是一个docker节点.多个节点就组成了一个网络集群(管理,工作者) Service 任务,可以在管理节点或者工作节点来运行,核心! 用户访问! Task 容器内的命令,细节任务! 一个大的服务里面有4个副本,每个副本就是一个小的task 命令 -> 管理 -> api -> 调度 -> 工作节点 (创建Task容器未出创建!) 在k8s的官网 拓展: 网络模式 : \"PublishMode\":\"ingress\" Swarm: Overlay: ingress: 特殊的Overlay网络! 负载均衡的功能! IPVS VIP! 虽然docker 在4台机器上,实际上网络是同一个! ingress 网络,是一个特殊的Overlay网络 网络变成了一个整体 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-22 19:58:08 "},"advance/13_docker_Docker其他命令学习方式.html":{"url":"advance/13_docker_Docker其他命令学习方式.html","title":"Docker其他命令学习方式","keywords":"","body":"Docker其它Docker其它 Docker Stack docker-compose 单机部署项目! Docker Stack部署,集群部署! # 单机 docker-compose up -d wordpress.yaml # 集群 docker stack deploy # docker-compose Docker Secret 安全!配置密码,证书! Docker Config 配置 docker 下半场 docker compose docker swarm new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-22 19:46:35 "},"advance/14_docker_Docker完结展望.html":{"url":"advance/14_docker_Docker完结展望.html","title":"Docker完结展望","keywords":"","body":" 扩展到K8s 云原生时代 微服务! 现在已经不搞微服务了 电商网站 在线教育平台... 这个现在不需要开发了 下载 => 配置 买服务器,部署配置k8s就成了 这个就是大趋势 首先你要精通k8s(容器编排) 云原生时代 Go语言! 必须掌握! Java ,Go Docker 是Go开发的 K8S也是Go的项目 Etcd都是Go的项目 现在所有的大公司,比如哔哩哔哩 后台在转向Go Go是一个并发语言 Go的来头非常大 B-C-Go 一堆大佬来创建的Go,首先Go语法与C相近,C的垃圾回收机制,Python的效率十分的慢 go中有指针的概念 入门 基础语法 高级对象 如何操作数据库 框架 Go语言成就了云原生时代,云原生时代让Go火了 Java => Go bytedance => Go P1 1、ElasticSearch课程简介 P2 2、聊聊Lucene创始人 P3 3、ElasticSearch概述 P4 4、Solr和ES的对比及选型 P5 5、ES安装及head插件安装 P6 6、Kibana的安装 P7 7、ES核心概念理解 P8 8、IK分词器详解 P9 9、Rest风格操作 P10 10、基本操作回顾 P11 11、花式查询详解 P12 12、SpringBoot集成ES详解 P13 13、关于索引的API操作详解 P14 14、关于文档的API操作详解 P15 15、京东搜索：项目搭建 P16 16、京东搜索：爬取数据 P17 17、京东搜索：业务编写 P18 18、京东搜索：前后端交互 P19 19、京东搜索：关键字高亮实现 P20 20、狂神聊ES小结new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-22 19:58:08 "},"advance/01-短信验证码-阿里云.html":{"url":"advance/01-短信验证码-阿里云.html","title":"短信验证码-阿里云","keywords":"","body":" 阿里云 开启子用户 新建一个用户组 创建一个用户 开通阿里云短信服务 收费规则 签名 开通阿里云短信服务 找到阿里云面板 找到帮助文档 参考 javaSDK Java代码 导入依赖 阿里云相关依赖和异常 换成变量 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-08-22 19:58:08 "}}